/* automatically generated by rust-bindgen */

pub type VkFlags = uint32_t;
pub type VkBool32 = uint32_t;
pub type VkDeviceSize = uint64_t;
pub type VkSampleMask = uint32_t;
pub enum Struct_VkInstance_T { }
pub type VkInstance = *mut Struct_VkInstance_T;
pub enum Struct_VkPhysicalDevice_T { }
pub type VkPhysicalDevice = *mut Struct_VkPhysicalDevice_T;
pub enum Struct_VkDevice_T { }
pub type VkDevice = *mut Struct_VkDevice_T;
pub enum Struct_VkQueue_T { }
pub type VkQueue = *mut Struct_VkQueue_T;
pub enum Struct_VkSemaphore_T { }
pub type VkSemaphore = *mut Struct_VkSemaphore_T;
pub enum Struct_VkCommandBuffer_T { }
pub type VkCommandBuffer = *mut Struct_VkCommandBuffer_T;
pub enum Struct_VkFence_T { }
pub type VkFence = *mut Struct_VkFence_T;
pub enum Struct_VkDeviceMemory_T { }
pub type VkDeviceMemory = *mut Struct_VkDeviceMemory_T;
pub enum Struct_VkBuffer_T { }
pub type VkBuffer = *mut Struct_VkBuffer_T;
pub enum Struct_VkImage_T { }
pub type VkImage = *mut Struct_VkImage_T;
pub enum Struct_VkEvent_T { }
pub type VkEvent = *mut Struct_VkEvent_T;
pub enum Struct_VkQueryPool_T { }
pub type VkQueryPool = *mut Struct_VkQueryPool_T;
pub enum Struct_VkBufferView_T { }
pub type VkBufferView = *mut Struct_VkBufferView_T;
pub enum Struct_VkImageView_T { }
pub type VkImageView = *mut Struct_VkImageView_T;
pub enum Struct_VkShaderModule_T { }
pub type VkShaderModule = *mut Struct_VkShaderModule_T;
pub enum Struct_VkPipelineCache_T { }
pub type VkPipelineCache = *mut Struct_VkPipelineCache_T;
pub enum Struct_VkPipelineLayout_T { }
pub type VkPipelineLayout = *mut Struct_VkPipelineLayout_T;
pub enum Struct_VkRenderPass_T { }
pub type VkRenderPass = *mut Struct_VkRenderPass_T;
pub enum Struct_VkPipeline_T { }
pub type VkPipeline = *mut Struct_VkPipeline_T;
pub enum Struct_VkDescriptorSetLayout_T { }
pub type VkDescriptorSetLayout = *mut Struct_VkDescriptorSetLayout_T;
pub enum Struct_VkSampler_T { }
pub type VkSampler = *mut Struct_VkSampler_T;
pub enum Struct_VkDescriptorPool_T { }
pub type VkDescriptorPool = *mut Struct_VkDescriptorPool_T;
pub enum Struct_VkDescriptorSet_T { }
pub type VkDescriptorSet = *mut Struct_VkDescriptorSet_T;
pub enum Struct_VkFramebuffer_T { }
pub type VkFramebuffer = *mut Struct_VkFramebuffer_T;
pub enum Struct_VkCommandPool_T { }
pub type VkCommandPool = *mut Struct_VkCommandPool_T;
pub const VK_PIPELINE_CACHE_HEADER_VERSION_BEGIN_RANGE:
          Enum_VkPipelineCacheHeaderVersion =
    Enum_VkPipelineCacheHeaderVersion::VK_PIPELINE_CACHE_HEADER_VERSION_ONE;
pub const VK_PIPELINE_CACHE_HEADER_VERSION_END_RANGE:
          Enum_VkPipelineCacheHeaderVersion =
    Enum_VkPipelineCacheHeaderVersion::VK_PIPELINE_CACHE_HEADER_VERSION_ONE;
pub const VK_PIPELINE_CACHE_HEADER_VERSION_RANGE_SIZE:
          Enum_VkPipelineCacheHeaderVersion =
    Enum_VkPipelineCacheHeaderVersion::VK_PIPELINE_CACHE_HEADER_VERSION_ONE;
#[derive(Clone, Eq, PartialEq, Debug, Copy)]
#[repr(u32)]
pub enum Enum_VkPipelineCacheHeaderVersion {
    VK_PIPELINE_CACHE_HEADER_VERSION_ONE = 1,
    VK_PIPELINE_CACHE_HEADER_VERSION_MAX_ENUM = 2147483647,
}
pub type VkPipelineCacheHeaderVersion = Enum_VkPipelineCacheHeaderVersion;
pub const VK_RESULT_BEGIN_RANGE: Enum_VkResult =
    Enum_VkResult::VK_ERROR_FORMAT_NOT_SUPPORTED;
pub const VK_RESULT_END_RANGE: Enum_VkResult = Enum_VkResult::VK_INCOMPLETE;
#[derive(Clone, Eq, PartialEq, Debug, Copy)]
#[repr(i32)]
pub enum Enum_VkResult {
    VK_SUCCESS = 0,
    VK_NOT_READY = 1,
    VK_TIMEOUT = 2,
    VK_EVENT_SET = 3,
    VK_EVENT_RESET = 4,
    VK_INCOMPLETE = 5,
    VK_ERROR_OUT_OF_HOST_MEMORY = -1,
    VK_ERROR_OUT_OF_DEVICE_MEMORY = -2,
    VK_ERROR_INITIALIZATION_FAILED = -3,
    VK_ERROR_DEVICE_LOST = -4,
    VK_ERROR_MEMORY_MAP_FAILED = -5,
    VK_ERROR_LAYER_NOT_PRESENT = -6,
    VK_ERROR_EXTENSION_NOT_PRESENT = -7,
    VK_ERROR_FEATURE_NOT_PRESENT = -8,
    VK_ERROR_INCOMPATIBLE_DRIVER = -9,
    VK_ERROR_TOO_MANY_OBJECTS = -10,
    VK_ERROR_FORMAT_NOT_SUPPORTED = -11,
    VK_ERROR_SURFACE_LOST_KHR = -1000000000,
    VK_ERROR_NATIVE_WINDOW_IN_USE_KHR = -1000000001,
    VK_SUBOPTIMAL_KHR = 1000001003,
    VK_ERROR_OUT_OF_DATE_KHR = -1000001004,
    VK_ERROR_INCOMPATIBLE_DISPLAY_KHR = -1000003001,
    VK_ERROR_VALIDATION_FAILED_EXT = -1000011001,
    VK_RESULT_RANGE_SIZE = 17,
    VK_RESULT_MAX_ENUM = 2147483647,
}
pub type VkResult = Enum_VkResult;
pub const VK_STRUCTURE_TYPE_BEGIN_RANGE: Enum_VkStructureType =
    Enum_VkStructureType::VK_STRUCTURE_TYPE_APPLICATION_INFO;
pub const VK_STRUCTURE_TYPE_END_RANGE: Enum_VkStructureType =
    Enum_VkStructureType::VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO;
#[derive(Clone, Eq, PartialEq, Debug, Copy)]
#[repr(u32)]
pub enum Enum_VkStructureType {
    VK_STRUCTURE_TYPE_APPLICATION_INFO = 0,
    VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO = 1,
    VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO = 2,
    VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO = 3,
    VK_STRUCTURE_TYPE_SUBMIT_INFO = 4,
    VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO = 5,
    VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE = 6,
    VK_STRUCTURE_TYPE_BIND_SPARSE_INFO = 7,
    VK_STRUCTURE_TYPE_FENCE_CREATE_INFO = 8,
    VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO = 9,
    VK_STRUCTURE_TYPE_EVENT_CREATE_INFO = 10,
    VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO = 11,
    VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO = 12,
    VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO = 13,
    VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO = 14,
    VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO = 15,
    VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO = 16,
    VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO = 17,
    VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO = 18,
    VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO = 19,
    VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO = 20,
    VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO = 21,
    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO = 22,
    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO = 23,
    VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO = 24,
    VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO = 25,
    VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO = 26,
    VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO = 27,
    VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO = 28,
    VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO = 29,
    VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO = 30,
    VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO = 31,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO = 32,
    VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO = 33,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO = 34,
    VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET = 35,
    VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET = 36,
    VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO = 37,
    VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO = 38,
    VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO = 39,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO = 40,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO = 41,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO = 42,
    VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO = 43,
    VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER = 44,
    VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER = 45,
    VK_STRUCTURE_TYPE_MEMORY_BARRIER = 46,
    VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO = 47,
    VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO = 48,
    VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR = 1000001000,
    VK_STRUCTURE_TYPE_PRESENT_INFO_KHR = 1000001001,
    VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR = 1000002000,
    VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR = 1000002001,
    VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR = 1000003000,
    VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR = 1000004000,
    VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR = 1000005000,
    VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR = 1000006000,
    VK_STRUCTURE_TYPE_MIR_SURFACE_CREATE_INFO_KHR = 1000007000,
    VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR = 1000008000,
    VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR = 1000009000,
    VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT = 1000011000,
    VK_STRUCTURE_TYPE_RANGE_SIZE = 49,
    VK_STRUCTURE_TYPE_MAX_ENUM = 2147483647,
}
pub type VkStructureType = Enum_VkStructureType;
pub const VK_SYSTEM_ALLOCATION_SCOPE_BEGIN_RANGE: Enum_VkSystemAllocationScope
          =
    Enum_VkSystemAllocationScope::VK_SYSTEM_ALLOCATION_SCOPE_COMMAND;
pub const VK_SYSTEM_ALLOCATION_SCOPE_END_RANGE: Enum_VkSystemAllocationScope =
    Enum_VkSystemAllocationScope::VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE;
#[derive(Clone, Eq, PartialEq, Debug, Copy)]
#[repr(u32)]
pub enum Enum_VkSystemAllocationScope {
    VK_SYSTEM_ALLOCATION_SCOPE_COMMAND = 0,
    VK_SYSTEM_ALLOCATION_SCOPE_OBJECT = 1,
    VK_SYSTEM_ALLOCATION_SCOPE_CACHE = 2,
    VK_SYSTEM_ALLOCATION_SCOPE_DEVICE = 3,
    VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE = 4,
    VK_SYSTEM_ALLOCATION_SCOPE_RANGE_SIZE = 5,
    VK_SYSTEM_ALLOCATION_SCOPE_MAX_ENUM = 2147483647,
}
pub type VkSystemAllocationScope = Enum_VkSystemAllocationScope;
pub const VK_INTERNAL_ALLOCATION_TYPE_BEGIN_RANGE:
          Enum_VkInternalAllocationType =
    Enum_VkInternalAllocationType::VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE;
pub const VK_INTERNAL_ALLOCATION_TYPE_END_RANGE: Enum_VkInternalAllocationType
          =
    Enum_VkInternalAllocationType::VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE;
#[derive(Clone, Eq, PartialEq, Debug, Copy)]
#[repr(u32)]
pub enum Enum_VkInternalAllocationType {
    VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE = 0,
    VK_INTERNAL_ALLOCATION_TYPE_RANGE_SIZE = 1,
    VK_INTERNAL_ALLOCATION_TYPE_MAX_ENUM = 2147483647,
}
pub type VkInternalAllocationType = Enum_VkInternalAllocationType;
pub const VK_FORMAT_BEGIN_RANGE: Enum_VkFormat =
    Enum_VkFormat::VK_FORMAT_UNDEFINED;
pub const VK_FORMAT_END_RANGE: Enum_VkFormat =
    Enum_VkFormat::VK_FORMAT_ASTC_12x12_SRGB_BLOCK;
#[derive(Clone, Eq, PartialEq, Debug, Copy)]
#[repr(u32)]
pub enum Enum_VkFormat {
    VK_FORMAT_UNDEFINED = 0,
    VK_FORMAT_R4G4_UNORM_PACK8 = 1,
    VK_FORMAT_R4G4B4A4_UNORM_PACK16 = 2,
    VK_FORMAT_B4G4R4A4_UNORM_PACK16 = 3,
    VK_FORMAT_R5G6B5_UNORM_PACK16 = 4,
    VK_FORMAT_B5G6R5_UNORM_PACK16 = 5,
    VK_FORMAT_R5G5B5A1_UNORM_PACK16 = 6,
    VK_FORMAT_B5G5R5A1_UNORM_PACK16 = 7,
    VK_FORMAT_A1R5G5B5_UNORM_PACK16 = 8,
    VK_FORMAT_R8_UNORM = 9,
    VK_FORMAT_R8_SNORM = 10,
    VK_FORMAT_R8_USCALED = 11,
    VK_FORMAT_R8_SSCALED = 12,
    VK_FORMAT_R8_UINT = 13,
    VK_FORMAT_R8_SINT = 14,
    VK_FORMAT_R8_SRGB = 15,
    VK_FORMAT_R8G8_UNORM = 16,
    VK_FORMAT_R8G8_SNORM = 17,
    VK_FORMAT_R8G8_USCALED = 18,
    VK_FORMAT_R8G8_SSCALED = 19,
    VK_FORMAT_R8G8_UINT = 20,
    VK_FORMAT_R8G8_SINT = 21,
    VK_FORMAT_R8G8_SRGB = 22,
    VK_FORMAT_R8G8B8_UNORM = 23,
    VK_FORMAT_R8G8B8_SNORM = 24,
    VK_FORMAT_R8G8B8_USCALED = 25,
    VK_FORMAT_R8G8B8_SSCALED = 26,
    VK_FORMAT_R8G8B8_UINT = 27,
    VK_FORMAT_R8G8B8_SINT = 28,
    VK_FORMAT_R8G8B8_SRGB = 29,
    VK_FORMAT_B8G8R8_UNORM = 30,
    VK_FORMAT_B8G8R8_SNORM = 31,
    VK_FORMAT_B8G8R8_USCALED = 32,
    VK_FORMAT_B8G8R8_SSCALED = 33,
    VK_FORMAT_B8G8R8_UINT = 34,
    VK_FORMAT_B8G8R8_SINT = 35,
    VK_FORMAT_B8G8R8_SRGB = 36,
    VK_FORMAT_R8G8B8A8_UNORM = 37,
    VK_FORMAT_R8G8B8A8_SNORM = 38,
    VK_FORMAT_R8G8B8A8_USCALED = 39,
    VK_FORMAT_R8G8B8A8_SSCALED = 40,
    VK_FORMAT_R8G8B8A8_UINT = 41,
    VK_FORMAT_R8G8B8A8_SINT = 42,
    VK_FORMAT_R8G8B8A8_SRGB = 43,
    VK_FORMAT_B8G8R8A8_UNORM = 44,
    VK_FORMAT_B8G8R8A8_SNORM = 45,
    VK_FORMAT_B8G8R8A8_USCALED = 46,
    VK_FORMAT_B8G8R8A8_SSCALED = 47,
    VK_FORMAT_B8G8R8A8_UINT = 48,
    VK_FORMAT_B8G8R8A8_SINT = 49,
    VK_FORMAT_B8G8R8A8_SRGB = 50,
    VK_FORMAT_A8B8G8R8_UNORM_PACK32 = 51,
    VK_FORMAT_A8B8G8R8_SNORM_PACK32 = 52,
    VK_FORMAT_A8B8G8R8_USCALED_PACK32 = 53,
    VK_FORMAT_A8B8G8R8_SSCALED_PACK32 = 54,
    VK_FORMAT_A8B8G8R8_UINT_PACK32 = 55,
    VK_FORMAT_A8B8G8R8_SINT_PACK32 = 56,
    VK_FORMAT_A8B8G8R8_SRGB_PACK32 = 57,
    VK_FORMAT_A2R10G10B10_UNORM_PACK32 = 58,
    VK_FORMAT_A2R10G10B10_SNORM_PACK32 = 59,
    VK_FORMAT_A2R10G10B10_USCALED_PACK32 = 60,
    VK_FORMAT_A2R10G10B10_SSCALED_PACK32 = 61,
    VK_FORMAT_A2R10G10B10_UINT_PACK32 = 62,
    VK_FORMAT_A2R10G10B10_SINT_PACK32 = 63,
    VK_FORMAT_A2B10G10R10_UNORM_PACK32 = 64,
    VK_FORMAT_A2B10G10R10_SNORM_PACK32 = 65,
    VK_FORMAT_A2B10G10R10_USCALED_PACK32 = 66,
    VK_FORMAT_A2B10G10R10_SSCALED_PACK32 = 67,
    VK_FORMAT_A2B10G10R10_UINT_PACK32 = 68,
    VK_FORMAT_A2B10G10R10_SINT_PACK32 = 69,
    VK_FORMAT_R16_UNORM = 70,
    VK_FORMAT_R16_SNORM = 71,
    VK_FORMAT_R16_USCALED = 72,
    VK_FORMAT_R16_SSCALED = 73,
    VK_FORMAT_R16_UINT = 74,
    VK_FORMAT_R16_SINT = 75,
    VK_FORMAT_R16_SFLOAT = 76,
    VK_FORMAT_R16G16_UNORM = 77,
    VK_FORMAT_R16G16_SNORM = 78,
    VK_FORMAT_R16G16_USCALED = 79,
    VK_FORMAT_R16G16_SSCALED = 80,
    VK_FORMAT_R16G16_UINT = 81,
    VK_FORMAT_R16G16_SINT = 82,
    VK_FORMAT_R16G16_SFLOAT = 83,
    VK_FORMAT_R16G16B16_UNORM = 84,
    VK_FORMAT_R16G16B16_SNORM = 85,
    VK_FORMAT_R16G16B16_USCALED = 86,
    VK_FORMAT_R16G16B16_SSCALED = 87,
    VK_FORMAT_R16G16B16_UINT = 88,
    VK_FORMAT_R16G16B16_SINT = 89,
    VK_FORMAT_R16G16B16_SFLOAT = 90,
    VK_FORMAT_R16G16B16A16_UNORM = 91,
    VK_FORMAT_R16G16B16A16_SNORM = 92,
    VK_FORMAT_R16G16B16A16_USCALED = 93,
    VK_FORMAT_R16G16B16A16_SSCALED = 94,
    VK_FORMAT_R16G16B16A16_UINT = 95,
    VK_FORMAT_R16G16B16A16_SINT = 96,
    VK_FORMAT_R16G16B16A16_SFLOAT = 97,
    VK_FORMAT_R32_UINT = 98,
    VK_FORMAT_R32_SINT = 99,
    VK_FORMAT_R32_SFLOAT = 100,
    VK_FORMAT_R32G32_UINT = 101,
    VK_FORMAT_R32G32_SINT = 102,
    VK_FORMAT_R32G32_SFLOAT = 103,
    VK_FORMAT_R32G32B32_UINT = 104,
    VK_FORMAT_R32G32B32_SINT = 105,
    VK_FORMAT_R32G32B32_SFLOAT = 106,
    VK_FORMAT_R32G32B32A32_UINT = 107,
    VK_FORMAT_R32G32B32A32_SINT = 108,
    VK_FORMAT_R32G32B32A32_SFLOAT = 109,
    VK_FORMAT_R64_UINT = 110,
    VK_FORMAT_R64_SINT = 111,
    VK_FORMAT_R64_SFLOAT = 112,
    VK_FORMAT_R64G64_UINT = 113,
    VK_FORMAT_R64G64_SINT = 114,
    VK_FORMAT_R64G64_SFLOAT = 115,
    VK_FORMAT_R64G64B64_UINT = 116,
    VK_FORMAT_R64G64B64_SINT = 117,
    VK_FORMAT_R64G64B64_SFLOAT = 118,
    VK_FORMAT_R64G64B64A64_UINT = 119,
    VK_FORMAT_R64G64B64A64_SINT = 120,
    VK_FORMAT_R64G64B64A64_SFLOAT = 121,
    VK_FORMAT_B10G11R11_UFLOAT_PACK32 = 122,
    VK_FORMAT_E5B9G9R9_UFLOAT_PACK32 = 123,
    VK_FORMAT_D16_UNORM = 124,
    VK_FORMAT_X8_D24_UNORM_PACK32 = 125,
    VK_FORMAT_D32_SFLOAT = 126,
    VK_FORMAT_S8_UINT = 127,
    VK_FORMAT_D16_UNORM_S8_UINT = 128,
    VK_FORMAT_D24_UNORM_S8_UINT = 129,
    VK_FORMAT_D32_SFLOAT_S8_UINT = 130,
    VK_FORMAT_BC1_RGB_UNORM_BLOCK = 131,
    VK_FORMAT_BC1_RGB_SRGB_BLOCK = 132,
    VK_FORMAT_BC1_RGBA_UNORM_BLOCK = 133,
    VK_FORMAT_BC1_RGBA_SRGB_BLOCK = 134,
    VK_FORMAT_BC2_UNORM_BLOCK = 135,
    VK_FORMAT_BC2_SRGB_BLOCK = 136,
    VK_FORMAT_BC3_UNORM_BLOCK = 137,
    VK_FORMAT_BC3_SRGB_BLOCK = 138,
    VK_FORMAT_BC4_UNORM_BLOCK = 139,
    VK_FORMAT_BC4_SNORM_BLOCK = 140,
    VK_FORMAT_BC5_UNORM_BLOCK = 141,
    VK_FORMAT_BC5_SNORM_BLOCK = 142,
    VK_FORMAT_BC6H_UFLOAT_BLOCK = 143,
    VK_FORMAT_BC6H_SFLOAT_BLOCK = 144,
    VK_FORMAT_BC7_UNORM_BLOCK = 145,
    VK_FORMAT_BC7_SRGB_BLOCK = 146,
    VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK = 147,
    VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK = 148,
    VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK = 149,
    VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK = 150,
    VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK = 151,
    VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK = 152,
    VK_FORMAT_EAC_R11_UNORM_BLOCK = 153,
    VK_FORMAT_EAC_R11_SNORM_BLOCK = 154,
    VK_FORMAT_EAC_R11G11_UNORM_BLOCK = 155,
    VK_FORMAT_EAC_R11G11_SNORM_BLOCK = 156,
    VK_FORMAT_ASTC_4x4_UNORM_BLOCK = 157,
    VK_FORMAT_ASTC_4x4_SRGB_BLOCK = 158,
    VK_FORMAT_ASTC_5x4_UNORM_BLOCK = 159,
    VK_FORMAT_ASTC_5x4_SRGB_BLOCK = 160,
    VK_FORMAT_ASTC_5x5_UNORM_BLOCK = 161,
    VK_FORMAT_ASTC_5x5_SRGB_BLOCK = 162,
    VK_FORMAT_ASTC_6x5_UNORM_BLOCK = 163,
    VK_FORMAT_ASTC_6x5_SRGB_BLOCK = 164,
    VK_FORMAT_ASTC_6x6_UNORM_BLOCK = 165,
    VK_FORMAT_ASTC_6x6_SRGB_BLOCK = 166,
    VK_FORMAT_ASTC_8x5_UNORM_BLOCK = 167,
    VK_FORMAT_ASTC_8x5_SRGB_BLOCK = 168,
    VK_FORMAT_ASTC_8x6_UNORM_BLOCK = 169,
    VK_FORMAT_ASTC_8x6_SRGB_BLOCK = 170,
    VK_FORMAT_ASTC_8x8_UNORM_BLOCK = 171,
    VK_FORMAT_ASTC_8x8_SRGB_BLOCK = 172,
    VK_FORMAT_ASTC_10x5_UNORM_BLOCK = 173,
    VK_FORMAT_ASTC_10x5_SRGB_BLOCK = 174,
    VK_FORMAT_ASTC_10x6_UNORM_BLOCK = 175,
    VK_FORMAT_ASTC_10x6_SRGB_BLOCK = 176,
    VK_FORMAT_ASTC_10x8_UNORM_BLOCK = 177,
    VK_FORMAT_ASTC_10x8_SRGB_BLOCK = 178,
    VK_FORMAT_ASTC_10x10_UNORM_BLOCK = 179,
    VK_FORMAT_ASTC_10x10_SRGB_BLOCK = 180,
    VK_FORMAT_ASTC_12x10_UNORM_BLOCK = 181,
    VK_FORMAT_ASTC_12x10_SRGB_BLOCK = 182,
    VK_FORMAT_ASTC_12x12_UNORM_BLOCK = 183,
    VK_FORMAT_ASTC_12x12_SRGB_BLOCK = 184,
    VK_FORMAT_RANGE_SIZE = 185,
    VK_FORMAT_MAX_ENUM = 2147483647,
}
pub type VkFormat = Enum_VkFormat;
pub const VK_IMAGE_TYPE_BEGIN_RANGE: Enum_VkImageType =
    Enum_VkImageType::VK_IMAGE_TYPE_1D;
pub const VK_IMAGE_TYPE_END_RANGE: Enum_VkImageType =
    Enum_VkImageType::VK_IMAGE_TYPE_3D;
#[derive(Clone, Eq, PartialEq, Debug, Copy)]
#[repr(u32)]
pub enum Enum_VkImageType {
    VK_IMAGE_TYPE_1D = 0,
    VK_IMAGE_TYPE_2D = 1,
    VK_IMAGE_TYPE_3D = 2,
    VK_IMAGE_TYPE_RANGE_SIZE = 3,
    VK_IMAGE_TYPE_MAX_ENUM = 2147483647,
}
pub type VkImageType = Enum_VkImageType;
pub const VK_IMAGE_TILING_BEGIN_RANGE: Enum_VkImageTiling =
    Enum_VkImageTiling::VK_IMAGE_TILING_OPTIMAL;
pub const VK_IMAGE_TILING_END_RANGE: Enum_VkImageTiling =
    Enum_VkImageTiling::VK_IMAGE_TILING_LINEAR;
#[derive(Clone, Eq, PartialEq, Debug, Copy)]
#[repr(u32)]
pub enum Enum_VkImageTiling {
    VK_IMAGE_TILING_OPTIMAL = 0,
    VK_IMAGE_TILING_LINEAR = 1,
    VK_IMAGE_TILING_RANGE_SIZE = 2,
    VK_IMAGE_TILING_MAX_ENUM = 2147483647,
}
pub type VkImageTiling = Enum_VkImageTiling;
pub const VK_PHYSICAL_DEVICE_TYPE_BEGIN_RANGE: Enum_VkPhysicalDeviceType =
    Enum_VkPhysicalDeviceType::VK_PHYSICAL_DEVICE_TYPE_OTHER;
pub const VK_PHYSICAL_DEVICE_TYPE_END_RANGE: Enum_VkPhysicalDeviceType =
    Enum_VkPhysicalDeviceType::VK_PHYSICAL_DEVICE_TYPE_CPU;
#[derive(Clone, Eq, PartialEq, Debug, Copy)]
#[repr(u32)]
pub enum Enum_VkPhysicalDeviceType {
    VK_PHYSICAL_DEVICE_TYPE_OTHER = 0,
    VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU = 1,
    VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU = 2,
    VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU = 3,
    VK_PHYSICAL_DEVICE_TYPE_CPU = 4,
    VK_PHYSICAL_DEVICE_TYPE_RANGE_SIZE = 5,
    VK_PHYSICAL_DEVICE_TYPE_MAX_ENUM = 2147483647,
}
pub type VkPhysicalDeviceType = Enum_VkPhysicalDeviceType;
pub const VK_QUERY_TYPE_BEGIN_RANGE: Enum_VkQueryType =
    Enum_VkQueryType::VK_QUERY_TYPE_OCCLUSION;
pub const VK_QUERY_TYPE_END_RANGE: Enum_VkQueryType =
    Enum_VkQueryType::VK_QUERY_TYPE_TIMESTAMP;
#[derive(Clone, Eq, PartialEq, Debug, Copy)]
#[repr(u32)]
pub enum Enum_VkQueryType {
    VK_QUERY_TYPE_OCCLUSION = 0,
    VK_QUERY_TYPE_PIPELINE_STATISTICS = 1,
    VK_QUERY_TYPE_TIMESTAMP = 2,
    VK_QUERY_TYPE_RANGE_SIZE = 3,
    VK_QUERY_TYPE_MAX_ENUM = 2147483647,
}
pub type VkQueryType = Enum_VkQueryType;
pub const VK_SHARING_MODE_BEGIN_RANGE: Enum_VkSharingMode =
    Enum_VkSharingMode::VK_SHARING_MODE_EXCLUSIVE;
pub const VK_SHARING_MODE_END_RANGE: Enum_VkSharingMode =
    Enum_VkSharingMode::VK_SHARING_MODE_CONCURRENT;
#[derive(Clone, Eq, PartialEq, Debug, Copy)]
#[repr(u32)]
pub enum Enum_VkSharingMode {
    VK_SHARING_MODE_EXCLUSIVE = 0,
    VK_SHARING_MODE_CONCURRENT = 1,
    VK_SHARING_MODE_RANGE_SIZE = 2,
    VK_SHARING_MODE_MAX_ENUM = 2147483647,
}
pub type VkSharingMode = Enum_VkSharingMode;
pub const VK_IMAGE_LAYOUT_BEGIN_RANGE: Enum_VkImageLayout =
    Enum_VkImageLayout::VK_IMAGE_LAYOUT_UNDEFINED;
pub const VK_IMAGE_LAYOUT_END_RANGE: Enum_VkImageLayout =
    Enum_VkImageLayout::VK_IMAGE_LAYOUT_PREINITIALIZED;
#[derive(Clone, Eq, PartialEq, Debug, Copy)]
#[repr(u32)]
pub enum Enum_VkImageLayout {
    VK_IMAGE_LAYOUT_UNDEFINED = 0,
    VK_IMAGE_LAYOUT_GENERAL = 1,
    VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL = 2,
    VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL = 3,
    VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL = 4,
    VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL = 5,
    VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL = 6,
    VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL = 7,
    VK_IMAGE_LAYOUT_PREINITIALIZED = 8,
    VK_IMAGE_LAYOUT_PRESENT_SRC_KHR = 1000001002,
    VK_IMAGE_LAYOUT_RANGE_SIZE = 9,
    VK_IMAGE_LAYOUT_MAX_ENUM = 2147483647,
}
pub type VkImageLayout = Enum_VkImageLayout;
pub const VK_IMAGE_VIEW_TYPE_BEGIN_RANGE: Enum_VkImageViewType =
    Enum_VkImageViewType::VK_IMAGE_VIEW_TYPE_1D;
pub const VK_IMAGE_VIEW_TYPE_END_RANGE: Enum_VkImageViewType =
    Enum_VkImageViewType::VK_IMAGE_VIEW_TYPE_CUBE_ARRAY;
#[derive(Clone, Eq, PartialEq, Debug, Copy)]
#[repr(u32)]
pub enum Enum_VkImageViewType {
    VK_IMAGE_VIEW_TYPE_1D = 0,
    VK_IMAGE_VIEW_TYPE_2D = 1,
    VK_IMAGE_VIEW_TYPE_3D = 2,
    VK_IMAGE_VIEW_TYPE_CUBE = 3,
    VK_IMAGE_VIEW_TYPE_1D_ARRAY = 4,
    VK_IMAGE_VIEW_TYPE_2D_ARRAY = 5,
    VK_IMAGE_VIEW_TYPE_CUBE_ARRAY = 6,
    VK_IMAGE_VIEW_TYPE_RANGE_SIZE = 7,
    VK_IMAGE_VIEW_TYPE_MAX_ENUM = 2147483647,
}
pub type VkImageViewType = Enum_VkImageViewType;
pub const VK_COMPONENT_SWIZZLE_BEGIN_RANGE: Enum_VkComponentSwizzle =
    Enum_VkComponentSwizzle::VK_COMPONENT_SWIZZLE_IDENTITY;
pub const VK_COMPONENT_SWIZZLE_END_RANGE: Enum_VkComponentSwizzle =
    Enum_VkComponentSwizzle::VK_COMPONENT_SWIZZLE_A;
#[derive(Clone, Eq, PartialEq, Debug, Copy)]
#[repr(u32)]
pub enum Enum_VkComponentSwizzle {
    VK_COMPONENT_SWIZZLE_IDENTITY = 0,
    VK_COMPONENT_SWIZZLE_ZERO = 1,
    VK_COMPONENT_SWIZZLE_ONE = 2,
    VK_COMPONENT_SWIZZLE_R = 3,
    VK_COMPONENT_SWIZZLE_G = 4,
    VK_COMPONENT_SWIZZLE_B = 5,
    VK_COMPONENT_SWIZZLE_A = 6,
    VK_COMPONENT_SWIZZLE_RANGE_SIZE = 7,
    VK_COMPONENT_SWIZZLE_MAX_ENUM = 2147483647,
}
pub type VkComponentSwizzle = Enum_VkComponentSwizzle;
pub const VK_VERTEX_INPUT_RATE_BEGIN_RANGE: Enum_VkVertexInputRate =
    Enum_VkVertexInputRate::VK_VERTEX_INPUT_RATE_VERTEX;
pub const VK_VERTEX_INPUT_RATE_END_RANGE: Enum_VkVertexInputRate =
    Enum_VkVertexInputRate::VK_VERTEX_INPUT_RATE_INSTANCE;
#[derive(Clone, Eq, PartialEq, Debug, Copy)]
#[repr(u32)]
pub enum Enum_VkVertexInputRate {
    VK_VERTEX_INPUT_RATE_VERTEX = 0,
    VK_VERTEX_INPUT_RATE_INSTANCE = 1,
    VK_VERTEX_INPUT_RATE_RANGE_SIZE = 2,
    VK_VERTEX_INPUT_RATE_MAX_ENUM = 2147483647,
}
pub type VkVertexInputRate = Enum_VkVertexInputRate;
pub const VK_PRIMITIVE_TOPOLOGY_BEGIN_RANGE: Enum_VkPrimitiveTopology =
    Enum_VkPrimitiveTopology::VK_PRIMITIVE_TOPOLOGY_POINT_LIST;
pub const VK_PRIMITIVE_TOPOLOGY_END_RANGE: Enum_VkPrimitiveTopology =
    Enum_VkPrimitiveTopology::VK_PRIMITIVE_TOPOLOGY_PATCH_LIST;
#[derive(Clone, Eq, PartialEq, Debug, Copy)]
#[repr(u32)]
pub enum Enum_VkPrimitiveTopology {
    VK_PRIMITIVE_TOPOLOGY_POINT_LIST = 0,
    VK_PRIMITIVE_TOPOLOGY_LINE_LIST = 1,
    VK_PRIMITIVE_TOPOLOGY_LINE_STRIP = 2,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST = 3,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP = 4,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN = 5,
    VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY = 6,
    VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY = 7,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY = 8,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY = 9,
    VK_PRIMITIVE_TOPOLOGY_PATCH_LIST = 10,
    VK_PRIMITIVE_TOPOLOGY_RANGE_SIZE = 11,
    VK_PRIMITIVE_TOPOLOGY_MAX_ENUM = 2147483647,
}
pub type VkPrimitiveTopology = Enum_VkPrimitiveTopology;
pub const VK_POLYGON_MODE_BEGIN_RANGE: Enum_VkPolygonMode =
    Enum_VkPolygonMode::VK_POLYGON_MODE_FILL;
pub const VK_POLYGON_MODE_END_RANGE: Enum_VkPolygonMode =
    Enum_VkPolygonMode::VK_POLYGON_MODE_POINT;
#[derive(Clone, Eq, PartialEq, Debug, Copy)]
#[repr(u32)]
pub enum Enum_VkPolygonMode {
    VK_POLYGON_MODE_FILL = 0,
    VK_POLYGON_MODE_LINE = 1,
    VK_POLYGON_MODE_POINT = 2,
    VK_POLYGON_MODE_RANGE_SIZE = 3,
    VK_POLYGON_MODE_MAX_ENUM = 2147483647,
}
pub type VkPolygonMode = Enum_VkPolygonMode;
pub const VK_FRONT_FACE_BEGIN_RANGE: Enum_VkFrontFace =
    Enum_VkFrontFace::VK_FRONT_FACE_COUNTER_CLOCKWISE;
pub const VK_FRONT_FACE_END_RANGE: Enum_VkFrontFace =
    Enum_VkFrontFace::VK_FRONT_FACE_CLOCKWISE;
#[derive(Clone, Eq, PartialEq, Debug, Copy)]
#[repr(u32)]
pub enum Enum_VkFrontFace {
    VK_FRONT_FACE_COUNTER_CLOCKWISE = 0,
    VK_FRONT_FACE_CLOCKWISE = 1,
    VK_FRONT_FACE_RANGE_SIZE = 2,
    VK_FRONT_FACE_MAX_ENUM = 2147483647,
}
pub type VkFrontFace = Enum_VkFrontFace;
pub const VK_COMPARE_OP_BEGIN_RANGE: Enum_VkCompareOp =
    Enum_VkCompareOp::VK_COMPARE_OP_NEVER;
pub const VK_COMPARE_OP_END_RANGE: Enum_VkCompareOp =
    Enum_VkCompareOp::VK_COMPARE_OP_ALWAYS;
#[derive(Clone, Eq, PartialEq, Debug, Copy)]
#[repr(u32)]
pub enum Enum_VkCompareOp {
    VK_COMPARE_OP_NEVER = 0,
    VK_COMPARE_OP_LESS = 1,
    VK_COMPARE_OP_EQUAL = 2,
    VK_COMPARE_OP_LESS_OR_EQUAL = 3,
    VK_COMPARE_OP_GREATER = 4,
    VK_COMPARE_OP_NOT_EQUAL = 5,
    VK_COMPARE_OP_GREATER_OR_EQUAL = 6,
    VK_COMPARE_OP_ALWAYS = 7,
    VK_COMPARE_OP_RANGE_SIZE = 8,
    VK_COMPARE_OP_MAX_ENUM = 2147483647,
}
pub type VkCompareOp = Enum_VkCompareOp;
pub const VK_STENCIL_OP_BEGIN_RANGE: Enum_VkStencilOp =
    Enum_VkStencilOp::VK_STENCIL_OP_KEEP;
pub const VK_STENCIL_OP_END_RANGE: Enum_VkStencilOp =
    Enum_VkStencilOp::VK_STENCIL_OP_DECREMENT_AND_WRAP;
#[derive(Clone, Eq, PartialEq, Debug, Copy)]
#[repr(u32)]
pub enum Enum_VkStencilOp {
    VK_STENCIL_OP_KEEP = 0,
    VK_STENCIL_OP_ZERO = 1,
    VK_STENCIL_OP_REPLACE = 2,
    VK_STENCIL_OP_INCREMENT_AND_CLAMP = 3,
    VK_STENCIL_OP_DECREMENT_AND_CLAMP = 4,
    VK_STENCIL_OP_INVERT = 5,
    VK_STENCIL_OP_INCREMENT_AND_WRAP = 6,
    VK_STENCIL_OP_DECREMENT_AND_WRAP = 7,
    VK_STENCIL_OP_RANGE_SIZE = 8,
    VK_STENCIL_OP_MAX_ENUM = 2147483647,
}
pub type VkStencilOp = Enum_VkStencilOp;
pub const VK_LOGIC_OP_BEGIN_RANGE: Enum_VkLogicOp =
    Enum_VkLogicOp::VK_LOGIC_OP_CLEAR;
pub const VK_LOGIC_OP_END_RANGE: Enum_VkLogicOp =
    Enum_VkLogicOp::VK_LOGIC_OP_SET;
#[derive(Clone, Eq, PartialEq, Debug, Copy)]
#[repr(u32)]
pub enum Enum_VkLogicOp {
    VK_LOGIC_OP_CLEAR = 0,
    VK_LOGIC_OP_AND = 1,
    VK_LOGIC_OP_AND_REVERSE = 2,
    VK_LOGIC_OP_COPY = 3,
    VK_LOGIC_OP_AND_INVERTED = 4,
    VK_LOGIC_OP_NO_OP = 5,
    VK_LOGIC_OP_XOR = 6,
    VK_LOGIC_OP_OR = 7,
    VK_LOGIC_OP_NOR = 8,
    VK_LOGIC_OP_EQUIVALENT = 9,
    VK_LOGIC_OP_INVERT = 10,
    VK_LOGIC_OP_OR_REVERSE = 11,
    VK_LOGIC_OP_COPY_INVERTED = 12,
    VK_LOGIC_OP_OR_INVERTED = 13,
    VK_LOGIC_OP_NAND = 14,
    VK_LOGIC_OP_SET = 15,
    VK_LOGIC_OP_RANGE_SIZE = 16,
    VK_LOGIC_OP_MAX_ENUM = 2147483647,
}
pub type VkLogicOp = Enum_VkLogicOp;
pub const VK_BLEND_FACTOR_BEGIN_RANGE: Enum_VkBlendFactor =
    Enum_VkBlendFactor::VK_BLEND_FACTOR_ZERO;
pub const VK_BLEND_FACTOR_END_RANGE: Enum_VkBlendFactor =
    Enum_VkBlendFactor::VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA;
#[derive(Clone, Eq, PartialEq, Debug, Copy)]
#[repr(u32)]
pub enum Enum_VkBlendFactor {
    VK_BLEND_FACTOR_ZERO = 0,
    VK_BLEND_FACTOR_ONE = 1,
    VK_BLEND_FACTOR_SRC_COLOR = 2,
    VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR = 3,
    VK_BLEND_FACTOR_DST_COLOR = 4,
    VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR = 5,
    VK_BLEND_FACTOR_SRC_ALPHA = 6,
    VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA = 7,
    VK_BLEND_FACTOR_DST_ALPHA = 8,
    VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA = 9,
    VK_BLEND_FACTOR_CONSTANT_COLOR = 10,
    VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR = 11,
    VK_BLEND_FACTOR_CONSTANT_ALPHA = 12,
    VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA = 13,
    VK_BLEND_FACTOR_SRC_ALPHA_SATURATE = 14,
    VK_BLEND_FACTOR_SRC1_COLOR = 15,
    VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR = 16,
    VK_BLEND_FACTOR_SRC1_ALPHA = 17,
    VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA = 18,
    VK_BLEND_FACTOR_RANGE_SIZE = 19,
    VK_BLEND_FACTOR_MAX_ENUM = 2147483647,
}
pub type VkBlendFactor = Enum_VkBlendFactor;
pub const VK_BLEND_OP_BEGIN_RANGE: Enum_VkBlendOp =
    Enum_VkBlendOp::VK_BLEND_OP_ADD;
pub const VK_BLEND_OP_END_RANGE: Enum_VkBlendOp =
    Enum_VkBlendOp::VK_BLEND_OP_MAX;
#[derive(Clone, Eq, PartialEq, Debug, Copy)]
#[repr(u32)]
pub enum Enum_VkBlendOp {
    VK_BLEND_OP_ADD = 0,
    VK_BLEND_OP_SUBTRACT = 1,
    VK_BLEND_OP_REVERSE_SUBTRACT = 2,
    VK_BLEND_OP_MIN = 3,
    VK_BLEND_OP_MAX = 4,
    VK_BLEND_OP_RANGE_SIZE = 5,
    VK_BLEND_OP_MAX_ENUM = 2147483647,
}
pub type VkBlendOp = Enum_VkBlendOp;
pub const VK_DYNAMIC_STATE_BEGIN_RANGE: Enum_VkDynamicState =
    Enum_VkDynamicState::VK_DYNAMIC_STATE_VIEWPORT;
pub const VK_DYNAMIC_STATE_END_RANGE: Enum_VkDynamicState =
    Enum_VkDynamicState::VK_DYNAMIC_STATE_STENCIL_REFERENCE;
#[derive(Clone, Eq, PartialEq, Debug, Copy)]
#[repr(u32)]
pub enum Enum_VkDynamicState {
    VK_DYNAMIC_STATE_VIEWPORT = 0,
    VK_DYNAMIC_STATE_SCISSOR = 1,
    VK_DYNAMIC_STATE_LINE_WIDTH = 2,
    VK_DYNAMIC_STATE_DEPTH_BIAS = 3,
    VK_DYNAMIC_STATE_BLEND_CONSTANTS = 4,
    VK_DYNAMIC_STATE_DEPTH_BOUNDS = 5,
    VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK = 6,
    VK_DYNAMIC_STATE_STENCIL_WRITE_MASK = 7,
    VK_DYNAMIC_STATE_STENCIL_REFERENCE = 8,
    VK_DYNAMIC_STATE_RANGE_SIZE = 9,
    VK_DYNAMIC_STATE_MAX_ENUM = 2147483647,
}
pub type VkDynamicState = Enum_VkDynamicState;
pub const VK_FILTER_BEGIN_RANGE: Enum_VkFilter =
    Enum_VkFilter::VK_FILTER_NEAREST;
pub const VK_FILTER_END_RANGE: Enum_VkFilter =
    Enum_VkFilter::VK_FILTER_LINEAR;
#[derive(Clone, Eq, PartialEq, Debug, Copy)]
#[repr(u32)]
pub enum Enum_VkFilter {
    VK_FILTER_NEAREST = 0,
    VK_FILTER_LINEAR = 1,
    VK_FILTER_RANGE_SIZE = 2,
    VK_FILTER_MAX_ENUM = 2147483647,
}
pub type VkFilter = Enum_VkFilter;
pub const VK_SAMPLER_MIPMAP_MODE_BEGIN_RANGE: Enum_VkSamplerMipmapMode =
    Enum_VkSamplerMipmapMode::VK_SAMPLER_MIPMAP_MODE_NEAREST;
pub const VK_SAMPLER_MIPMAP_MODE_END_RANGE: Enum_VkSamplerMipmapMode =
    Enum_VkSamplerMipmapMode::VK_SAMPLER_MIPMAP_MODE_LINEAR;
#[derive(Clone, Eq, PartialEq, Debug, Copy)]
#[repr(u32)]
pub enum Enum_VkSamplerMipmapMode {
    VK_SAMPLER_MIPMAP_MODE_NEAREST = 0,
    VK_SAMPLER_MIPMAP_MODE_LINEAR = 1,
    VK_SAMPLER_MIPMAP_MODE_RANGE_SIZE = 2,
    VK_SAMPLER_MIPMAP_MODE_MAX_ENUM = 2147483647,
}
pub type VkSamplerMipmapMode = Enum_VkSamplerMipmapMode;
pub const VK_SAMPLER_ADDRESS_MODE_BEGIN_RANGE: Enum_VkSamplerAddressMode =
    Enum_VkSamplerAddressMode::VK_SAMPLER_ADDRESS_MODE_REPEAT;
pub const VK_SAMPLER_ADDRESS_MODE_END_RANGE: Enum_VkSamplerAddressMode =
    Enum_VkSamplerAddressMode::VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE;
#[derive(Clone, Eq, PartialEq, Debug, Copy)]
#[repr(u32)]
pub enum Enum_VkSamplerAddressMode {
    VK_SAMPLER_ADDRESS_MODE_REPEAT = 0,
    VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT = 1,
    VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE = 2,
    VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER = 3,
    VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE = 4,
    VK_SAMPLER_ADDRESS_MODE_RANGE_SIZE = 5,
    VK_SAMPLER_ADDRESS_MODE_MAX_ENUM = 2147483647,
}
pub type VkSamplerAddressMode = Enum_VkSamplerAddressMode;
pub const VK_BORDER_COLOR_BEGIN_RANGE: Enum_VkBorderColor =
    Enum_VkBorderColor::VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK;
pub const VK_BORDER_COLOR_END_RANGE: Enum_VkBorderColor =
    Enum_VkBorderColor::VK_BORDER_COLOR_INT_OPAQUE_WHITE;
#[derive(Clone, Eq, PartialEq, Debug, Copy)]
#[repr(u32)]
pub enum Enum_VkBorderColor {
    VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK = 0,
    VK_BORDER_COLOR_INT_TRANSPARENT_BLACK = 1,
    VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK = 2,
    VK_BORDER_COLOR_INT_OPAQUE_BLACK = 3,
    VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE = 4,
    VK_BORDER_COLOR_INT_OPAQUE_WHITE = 5,
    VK_BORDER_COLOR_RANGE_SIZE = 6,
    VK_BORDER_COLOR_MAX_ENUM = 2147483647,
}
pub type VkBorderColor = Enum_VkBorderColor;
pub const VK_DESCRIPTOR_TYPE_BEGIN_RANGE: Enum_VkDescriptorType =
    Enum_VkDescriptorType::VK_DESCRIPTOR_TYPE_SAMPLER;
pub const VK_DESCRIPTOR_TYPE_END_RANGE: Enum_VkDescriptorType =
    Enum_VkDescriptorType::VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT;
#[derive(Clone, Eq, PartialEq, Debug, Copy)]
#[repr(u32)]
pub enum Enum_VkDescriptorType {
    VK_DESCRIPTOR_TYPE_SAMPLER = 0,
    VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER = 1,
    VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE = 2,
    VK_DESCRIPTOR_TYPE_STORAGE_IMAGE = 3,
    VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER = 4,
    VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER = 5,
    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER = 6,
    VK_DESCRIPTOR_TYPE_STORAGE_BUFFER = 7,
    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC = 8,
    VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC = 9,
    VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT = 10,
    VK_DESCRIPTOR_TYPE_RANGE_SIZE = 11,
    VK_DESCRIPTOR_TYPE_MAX_ENUM = 2147483647,
}
pub type VkDescriptorType = Enum_VkDescriptorType;
pub const VK_ATTACHMENT_LOAD_OP_BEGIN_RANGE: Enum_VkAttachmentLoadOp =
    Enum_VkAttachmentLoadOp::VK_ATTACHMENT_LOAD_OP_LOAD;
pub const VK_ATTACHMENT_LOAD_OP_END_RANGE: Enum_VkAttachmentLoadOp =
    Enum_VkAttachmentLoadOp::VK_ATTACHMENT_LOAD_OP_DONT_CARE;
#[derive(Clone, Eq, PartialEq, Debug, Copy)]
#[repr(u32)]
pub enum Enum_VkAttachmentLoadOp {
    VK_ATTACHMENT_LOAD_OP_LOAD = 0,
    VK_ATTACHMENT_LOAD_OP_CLEAR = 1,
    VK_ATTACHMENT_LOAD_OP_DONT_CARE = 2,
    VK_ATTACHMENT_LOAD_OP_RANGE_SIZE = 3,
    VK_ATTACHMENT_LOAD_OP_MAX_ENUM = 2147483647,
}
pub type VkAttachmentLoadOp = Enum_VkAttachmentLoadOp;
pub const VK_ATTACHMENT_STORE_OP_BEGIN_RANGE: Enum_VkAttachmentStoreOp =
    Enum_VkAttachmentStoreOp::VK_ATTACHMENT_STORE_OP_STORE;
pub const VK_ATTACHMENT_STORE_OP_END_RANGE: Enum_VkAttachmentStoreOp =
    Enum_VkAttachmentStoreOp::VK_ATTACHMENT_STORE_OP_DONT_CARE;
#[derive(Clone, Eq, PartialEq, Debug, Copy)]
#[repr(u32)]
pub enum Enum_VkAttachmentStoreOp {
    VK_ATTACHMENT_STORE_OP_STORE = 0,
    VK_ATTACHMENT_STORE_OP_DONT_CARE = 1,
    VK_ATTACHMENT_STORE_OP_RANGE_SIZE = 2,
    VK_ATTACHMENT_STORE_OP_MAX_ENUM = 2147483647,
}
pub type VkAttachmentStoreOp = Enum_VkAttachmentStoreOp;
pub const VK_PIPELINE_BIND_POINT_BEGIN_RANGE: Enum_VkPipelineBindPoint =
    Enum_VkPipelineBindPoint::VK_PIPELINE_BIND_POINT_GRAPHICS;
pub const VK_PIPELINE_BIND_POINT_END_RANGE: Enum_VkPipelineBindPoint =
    Enum_VkPipelineBindPoint::VK_PIPELINE_BIND_POINT_COMPUTE;
#[derive(Clone, Eq, PartialEq, Debug, Copy)]
#[repr(u32)]
pub enum Enum_VkPipelineBindPoint {
    VK_PIPELINE_BIND_POINT_GRAPHICS = 0,
    VK_PIPELINE_BIND_POINT_COMPUTE = 1,
    VK_PIPELINE_BIND_POINT_RANGE_SIZE = 2,
    VK_PIPELINE_BIND_POINT_MAX_ENUM = 2147483647,
}
pub type VkPipelineBindPoint = Enum_VkPipelineBindPoint;
pub const VK_COMMAND_BUFFER_LEVEL_BEGIN_RANGE: Enum_VkCommandBufferLevel =
    Enum_VkCommandBufferLevel::VK_COMMAND_BUFFER_LEVEL_PRIMARY;
pub const VK_COMMAND_BUFFER_LEVEL_END_RANGE: Enum_VkCommandBufferLevel =
    Enum_VkCommandBufferLevel::VK_COMMAND_BUFFER_LEVEL_SECONDARY;
#[derive(Clone, Eq, PartialEq, Debug, Copy)]
#[repr(u32)]
pub enum Enum_VkCommandBufferLevel {
    VK_COMMAND_BUFFER_LEVEL_PRIMARY = 0,
    VK_COMMAND_BUFFER_LEVEL_SECONDARY = 1,
    VK_COMMAND_BUFFER_LEVEL_RANGE_SIZE = 2,
    VK_COMMAND_BUFFER_LEVEL_MAX_ENUM = 2147483647,
}
pub type VkCommandBufferLevel = Enum_VkCommandBufferLevel;
pub const VK_INDEX_TYPE_BEGIN_RANGE: Enum_VkIndexType =
    Enum_VkIndexType::VK_INDEX_TYPE_UINT16;
pub const VK_INDEX_TYPE_END_RANGE: Enum_VkIndexType =
    Enum_VkIndexType::VK_INDEX_TYPE_UINT32;
#[derive(Clone, Eq, PartialEq, Debug, Copy)]
#[repr(u32)]
pub enum Enum_VkIndexType {
    VK_INDEX_TYPE_UINT16 = 0,
    VK_INDEX_TYPE_UINT32 = 1,
    VK_INDEX_TYPE_RANGE_SIZE = 2,
    VK_INDEX_TYPE_MAX_ENUM = 2147483647,
}
pub type VkIndexType = Enum_VkIndexType;
pub const VK_SUBPASS_CONTENTS_BEGIN_RANGE: Enum_VkSubpassContents =
    Enum_VkSubpassContents::VK_SUBPASS_CONTENTS_INLINE;
pub const VK_SUBPASS_CONTENTS_END_RANGE: Enum_VkSubpassContents =
    Enum_VkSubpassContents::VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS;
#[derive(Clone, Eq, PartialEq, Debug, Copy)]
#[repr(u32)]
pub enum Enum_VkSubpassContents {
    VK_SUBPASS_CONTENTS_INLINE = 0,
    VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS = 1,
    VK_SUBPASS_CONTENTS_RANGE_SIZE = 2,
    VK_SUBPASS_CONTENTS_MAX_ENUM = 2147483647,
}
pub type VkSubpassContents = Enum_VkSubpassContents;
pub type VkInstanceCreateFlags = VkFlags;
#[derive(Clone, Eq, PartialEq, Debug, Copy)]
#[repr(u32)]
pub enum Enum_VkFormatFeatureFlagBits {
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT = 1,
    VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT = 2,
    VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT = 4,
    VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT = 8,
    VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT = 16,
    VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT = 32,
    VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT = 64,
    VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT = 128,
    VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT = 256,
    VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT = 512,
    VK_FORMAT_FEATURE_BLIT_SRC_BIT = 1024,
    VK_FORMAT_FEATURE_BLIT_DST_BIT = 2048,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT = 4096,
}
pub type VkFormatFeatureFlagBits = Enum_VkFormatFeatureFlagBits;
pub type VkFormatFeatureFlags = VkFlags;
#[derive(Clone, Eq, PartialEq, Debug, Copy)]
#[repr(u32)]
pub enum Enum_VkImageUsageFlagBits {
    VK_IMAGE_USAGE_TRANSFER_SRC_BIT = 1,
    VK_IMAGE_USAGE_TRANSFER_DST_BIT = 2,
    VK_IMAGE_USAGE_SAMPLED_BIT = 4,
    VK_IMAGE_USAGE_STORAGE_BIT = 8,
    VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT = 16,
    VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT = 32,
    VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT = 64,
    VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT = 128,
}
pub type VkImageUsageFlagBits = Enum_VkImageUsageFlagBits;
pub type VkImageUsageFlags = VkFlags;
#[derive(Clone, Eq, PartialEq, Debug, Copy)]
#[repr(u32)]
pub enum Enum_VkImageCreateFlagBits {
    VK_IMAGE_CREATE_SPARSE_BINDING_BIT = 1,
    VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT = 2,
    VK_IMAGE_CREATE_SPARSE_ALIASED_BIT = 4,
    VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT = 8,
    VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT = 16,
}
pub type VkImageCreateFlagBits = Enum_VkImageCreateFlagBits;
pub type VkImageCreateFlags = VkFlags;
#[derive(Clone, Eq, PartialEq, Debug, Copy)]
#[repr(u32)]
pub enum Enum_VkSampleCountFlagBits {
    VK_SAMPLE_COUNT_1_BIT = 1,
    VK_SAMPLE_COUNT_2_BIT = 2,
    VK_SAMPLE_COUNT_4_BIT = 4,
    VK_SAMPLE_COUNT_8_BIT = 8,
    VK_SAMPLE_COUNT_16_BIT = 16,
    VK_SAMPLE_COUNT_32_BIT = 32,
    VK_SAMPLE_COUNT_64_BIT = 64,
}
pub type VkSampleCountFlagBits = Enum_VkSampleCountFlagBits;
pub type VkSampleCountFlags = VkFlags;
#[derive(Clone, Eq, PartialEq, Debug, Copy)]
#[repr(u32)]
pub enum Enum_VkQueueFlagBits {
    VK_QUEUE_GRAPHICS_BIT = 1,
    VK_QUEUE_COMPUTE_BIT = 2,
    VK_QUEUE_TRANSFER_BIT = 4,
    VK_QUEUE_SPARSE_BINDING_BIT = 8,
}
pub type VkQueueFlagBits = Enum_VkQueueFlagBits;
pub type VkQueueFlags = VkFlags;
#[derive(Clone, Eq, PartialEq, Debug, Copy)]
#[repr(u32)]
pub enum Enum_VkMemoryPropertyFlagBits {
    VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT = 1,
    VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT = 2,
    VK_MEMORY_PROPERTY_HOST_COHERENT_BIT = 4,
    VK_MEMORY_PROPERTY_HOST_CACHED_BIT = 8,
    VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT = 16,
}
pub type VkMemoryPropertyFlagBits = Enum_VkMemoryPropertyFlagBits;
pub type VkMemoryPropertyFlags = VkFlags;
#[derive(Clone, Eq, PartialEq, Debug, Copy)]
#[repr(u32)]
pub enum Enum_VkMemoryHeapFlagBits { VK_MEMORY_HEAP_DEVICE_LOCAL_BIT = 1, }
pub type VkMemoryHeapFlagBits = Enum_VkMemoryHeapFlagBits;
pub type VkMemoryHeapFlags = VkFlags;
pub type VkDeviceCreateFlags = VkFlags;
pub type VkDeviceQueueCreateFlags = VkFlags;
#[derive(Clone, Eq, PartialEq, Debug, Copy)]
#[repr(u32)]
pub enum Enum_VkPipelineStageFlagBits {
    VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT = 1,
    VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT = 2,
    VK_PIPELINE_STAGE_VERTEX_INPUT_BIT = 4,
    VK_PIPELINE_STAGE_VERTEX_SHADER_BIT = 8,
    VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT = 16,
    VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT = 32,
    VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT = 64,
    VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT = 128,
    VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT = 256,
    VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT = 512,
    VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT = 1024,
    VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT = 2048,
    VK_PIPELINE_STAGE_TRANSFER_BIT = 4096,
    VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT = 8192,
    VK_PIPELINE_STAGE_HOST_BIT = 16384,
    VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT = 32768,
    VK_PIPELINE_STAGE_ALL_COMMANDS_BIT = 65536,
}
pub type VkPipelineStageFlagBits = Enum_VkPipelineStageFlagBits;
pub type VkPipelineStageFlags = VkFlags;
pub type VkMemoryMapFlags = VkFlags;
#[derive(Clone, Eq, PartialEq, Debug, Copy)]
#[repr(u32)]
pub enum Enum_VkImageAspectFlagBits {
    VK_IMAGE_ASPECT_COLOR_BIT = 1,
    VK_IMAGE_ASPECT_DEPTH_BIT = 2,
    VK_IMAGE_ASPECT_STENCIL_BIT = 4,
    VK_IMAGE_ASPECT_METADATA_BIT = 8,
}
pub type VkImageAspectFlagBits = Enum_VkImageAspectFlagBits;
pub type VkImageAspectFlags = VkFlags;
#[derive(Clone, Eq, PartialEq, Debug, Copy)]
#[repr(u32)]
pub enum Enum_VkSparseImageFormatFlagBits {
    VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT = 1,
    VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT = 2,
    VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT = 4,
}
pub type VkSparseImageFormatFlagBits = Enum_VkSparseImageFormatFlagBits;
pub type VkSparseImageFormatFlags = VkFlags;
#[derive(Clone, Eq, PartialEq, Debug, Copy)]
#[repr(u32)]
pub enum Enum_VkSparseMemoryBindFlagBits {
    VK_SPARSE_MEMORY_BIND_METADATA_BIT = 1,
}
pub type VkSparseMemoryBindFlagBits = Enum_VkSparseMemoryBindFlagBits;
pub type VkSparseMemoryBindFlags = VkFlags;
#[derive(Clone, Eq, PartialEq, Debug, Copy)]
#[repr(u32)]
pub enum Enum_VkFenceCreateFlagBits { VK_FENCE_CREATE_SIGNALED_BIT = 1, }
pub type VkFenceCreateFlagBits = Enum_VkFenceCreateFlagBits;
pub type VkFenceCreateFlags = VkFlags;
pub type VkSemaphoreCreateFlags = VkFlags;
pub type VkEventCreateFlags = VkFlags;
pub type VkQueryPoolCreateFlags = VkFlags;
#[derive(Clone, Eq, PartialEq, Debug, Copy)]
#[repr(u32)]
pub enum Enum_VkQueryPipelineStatisticFlagBits {
    VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT = 1,
    VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT = 2,
    VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT = 4,
    VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT = 8,
    VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT = 16,
    VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT = 32,
    VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT = 64,
    VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT = 128,
    VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT = 256,
    VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT
        = 512,
    VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT = 1024,
}
pub type VkQueryPipelineStatisticFlagBits =
    Enum_VkQueryPipelineStatisticFlagBits;
pub type VkQueryPipelineStatisticFlags = VkFlags;
#[derive(Clone, Eq, PartialEq, Debug, Copy)]
#[repr(u32)]
pub enum Enum_VkQueryResultFlagBits {
    VK_QUERY_RESULT_64_BIT = 1,
    VK_QUERY_RESULT_WAIT_BIT = 2,
    VK_QUERY_RESULT_WITH_AVAILABILITY_BIT = 4,
    VK_QUERY_RESULT_PARTIAL_BIT = 8,
}
pub type VkQueryResultFlagBits = Enum_VkQueryResultFlagBits;
pub type VkQueryResultFlags = VkFlags;
#[derive(Clone, Eq, PartialEq, Debug, Copy)]
#[repr(u32)]
pub enum Enum_VkBufferCreateFlagBits {
    VK_BUFFER_CREATE_SPARSE_BINDING_BIT = 1,
    VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT = 2,
    VK_BUFFER_CREATE_SPARSE_ALIASED_BIT = 4,
}
pub type VkBufferCreateFlagBits = Enum_VkBufferCreateFlagBits;
pub type VkBufferCreateFlags = VkFlags;
#[derive(Clone, Eq, PartialEq, Debug, Copy)]
#[repr(u32)]
pub enum Enum_VkBufferUsageFlagBits {
    VK_BUFFER_USAGE_TRANSFER_SRC_BIT = 1,
    VK_BUFFER_USAGE_TRANSFER_DST_BIT = 2,
    VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT = 4,
    VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT = 8,
    VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT = 16,
    VK_BUFFER_USAGE_STORAGE_BUFFER_BIT = 32,
    VK_BUFFER_USAGE_INDEX_BUFFER_BIT = 64,
    VK_BUFFER_USAGE_VERTEX_BUFFER_BIT = 128,
    VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT = 256,
}
pub type VkBufferUsageFlagBits = Enum_VkBufferUsageFlagBits;
pub type VkBufferUsageFlags = VkFlags;
pub type VkBufferViewCreateFlags = VkFlags;
pub type VkImageViewCreateFlags = VkFlags;
pub type VkShaderModuleCreateFlags = VkFlags;
pub type VkPipelineCacheCreateFlags = VkFlags;
#[derive(Clone, Eq, PartialEq, Debug, Copy)]
#[repr(u32)]
pub enum Enum_VkPipelineCreateFlagBits {
    VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT = 1,
    VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT = 2,
    VK_PIPELINE_CREATE_DERIVATIVE_BIT = 4,
}
pub type VkPipelineCreateFlagBits = Enum_VkPipelineCreateFlagBits;
pub type VkPipelineCreateFlags = VkFlags;
pub type VkPipelineShaderStageCreateFlags = VkFlags;
#[derive(Clone, Eq, PartialEq, Debug, Copy)]
#[repr(u32)]
pub enum Enum_VkShaderStageFlagBits {
    VK_SHADER_STAGE_VERTEX_BIT = 1,
    VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT = 2,
    VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT = 4,
    VK_SHADER_STAGE_GEOMETRY_BIT = 8,
    VK_SHADER_STAGE_FRAGMENT_BIT = 16,
    VK_SHADER_STAGE_COMPUTE_BIT = 32,
    VK_SHADER_STAGE_ALL_GRAPHICS = 31,
    VK_SHADER_STAGE_ALL = 2147483647,
}
pub type VkShaderStageFlagBits = Enum_VkShaderStageFlagBits;
pub type VkPipelineVertexInputStateCreateFlags = VkFlags;
pub type VkPipelineInputAssemblyStateCreateFlags = VkFlags;
pub type VkPipelineTessellationStateCreateFlags = VkFlags;
pub type VkPipelineViewportStateCreateFlags = VkFlags;
pub type VkPipelineRasterizationStateCreateFlags = VkFlags;
#[derive(Clone, Eq, PartialEq, Debug, Copy)]
#[repr(u32)]
pub enum Enum_VkCullModeFlagBits {
    VK_CULL_MODE_NONE = 0,
    VK_CULL_MODE_FRONT_BIT = 1,
    VK_CULL_MODE_BACK_BIT = 2,
    VK_CULL_MODE_FRONT_AND_BACK = 3,
}
pub type VkCullModeFlagBits = Enum_VkCullModeFlagBits;
pub type VkCullModeFlags = VkFlags;
pub type VkPipelineMultisampleStateCreateFlags = VkFlags;
pub type VkPipelineDepthStencilStateCreateFlags = VkFlags;
pub type VkPipelineColorBlendStateCreateFlags = VkFlags;
#[derive(Clone, Eq, PartialEq, Debug, Copy)]
#[repr(u32)]
pub enum Enum_VkColorComponentFlagBits {
    VK_COLOR_COMPONENT_R_BIT = 1,
    VK_COLOR_COMPONENT_G_BIT = 2,
    VK_COLOR_COMPONENT_B_BIT = 4,
    VK_COLOR_COMPONENT_A_BIT = 8,
}
pub type VkColorComponentFlagBits = Enum_VkColorComponentFlagBits;
pub type VkColorComponentFlags = VkFlags;
pub type VkPipelineDynamicStateCreateFlags = VkFlags;
pub type VkPipelineLayoutCreateFlags = VkFlags;
pub type VkShaderStageFlags = VkFlags;
pub type VkSamplerCreateFlags = VkFlags;
pub type VkDescriptorSetLayoutCreateFlags = VkFlags;
#[derive(Clone, Eq, PartialEq, Debug, Copy)]
#[repr(u32)]
pub enum Enum_VkDescriptorPoolCreateFlagBits {
    VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT = 1,
}
pub type VkDescriptorPoolCreateFlagBits = Enum_VkDescriptorPoolCreateFlagBits;
pub type VkDescriptorPoolCreateFlags = VkFlags;
pub type VkDescriptorPoolResetFlags = VkFlags;
pub type VkFramebufferCreateFlags = VkFlags;
pub type VkRenderPassCreateFlags = VkFlags;
#[derive(Clone, Eq, PartialEq, Debug, Copy)]
#[repr(u32)]
pub enum Enum_VkAttachmentDescriptionFlagBits {
    VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT = 1,
}
pub type VkAttachmentDescriptionFlagBits =
    Enum_VkAttachmentDescriptionFlagBits;
pub type VkAttachmentDescriptionFlags = VkFlags;
pub type VkSubpassDescriptionFlags = VkFlags;
#[derive(Clone, Eq, PartialEq, Debug, Copy)]
#[repr(u32)]
pub enum Enum_VkAccessFlagBits {
    VK_ACCESS_INDIRECT_COMMAND_READ_BIT = 1,
    VK_ACCESS_INDEX_READ_BIT = 2,
    VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT = 4,
    VK_ACCESS_UNIFORM_READ_BIT = 8,
    VK_ACCESS_INPUT_ATTACHMENT_READ_BIT = 16,
    VK_ACCESS_SHADER_READ_BIT = 32,
    VK_ACCESS_SHADER_WRITE_BIT = 64,
    VK_ACCESS_COLOR_ATTACHMENT_READ_BIT = 128,
    VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT = 256,
    VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT = 512,
    VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT = 1024,
    VK_ACCESS_TRANSFER_READ_BIT = 2048,
    VK_ACCESS_TRANSFER_WRITE_BIT = 4096,
    VK_ACCESS_HOST_READ_BIT = 8192,
    VK_ACCESS_HOST_WRITE_BIT = 16384,
    VK_ACCESS_MEMORY_READ_BIT = 32768,
    VK_ACCESS_MEMORY_WRITE_BIT = 65536,
}
pub type VkAccessFlagBits = Enum_VkAccessFlagBits;
pub type VkAccessFlags = VkFlags;
#[derive(Clone, Eq, PartialEq, Debug, Copy)]
#[repr(u32)]
pub enum Enum_VkDependencyFlagBits { VK_DEPENDENCY_BY_REGION_BIT = 1, }
pub type VkDependencyFlagBits = Enum_VkDependencyFlagBits;
pub type VkDependencyFlags = VkFlags;
#[derive(Clone, Eq, PartialEq, Debug, Copy)]
#[repr(u32)]
pub enum Enum_VkCommandPoolCreateFlagBits {
    VK_COMMAND_POOL_CREATE_TRANSIENT_BIT = 1,
    VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT = 2,
}
pub type VkCommandPoolCreateFlagBits = Enum_VkCommandPoolCreateFlagBits;
pub type VkCommandPoolCreateFlags = VkFlags;
#[derive(Clone, Eq, PartialEq, Debug, Copy)]
#[repr(u32)]
pub enum Enum_VkCommandPoolResetFlagBits {
    VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT = 1,
}
pub type VkCommandPoolResetFlagBits = Enum_VkCommandPoolResetFlagBits;
pub type VkCommandPoolResetFlags = VkFlags;
#[derive(Clone, Eq, PartialEq, Debug, Copy)]
#[repr(u32)]
pub enum Enum_VkCommandBufferUsageFlagBits {
    VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT = 1,
    VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT = 2,
    VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT = 4,
}
pub type VkCommandBufferUsageFlagBits = Enum_VkCommandBufferUsageFlagBits;
pub type VkCommandBufferUsageFlags = VkFlags;
#[derive(Clone, Eq, PartialEq, Debug, Copy)]
#[repr(u32)]
pub enum Enum_VkQueryControlFlagBits { VK_QUERY_CONTROL_PRECISE_BIT = 1, }
pub type VkQueryControlFlagBits = Enum_VkQueryControlFlagBits;
pub type VkQueryControlFlags = VkFlags;
#[derive(Clone, Eq, PartialEq, Debug, Copy)]
#[repr(u32)]
pub enum Enum_VkCommandBufferResetFlagBits {
    VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT = 1,
}
pub type VkCommandBufferResetFlagBits = Enum_VkCommandBufferResetFlagBits;
pub type VkCommandBufferResetFlags = VkFlags;
#[derive(Clone, Eq, PartialEq, Debug, Copy)]
#[repr(u32)]
pub enum Enum_VkStencilFaceFlagBits {
    VK_STENCIL_FACE_FRONT_BIT = 1,
    VK_STENCIL_FACE_BACK_BIT = 2,
    VK_STENCIL_FRONT_AND_BACK = 3,
}
pub type VkStencilFaceFlagBits = Enum_VkStencilFaceFlagBits;
pub type VkStencilFaceFlags = VkFlags;
pub type PFN_vkAllocationFunction =
    ::std::option::Option<unsafe extern "C" fn(pUserData:
                                                   *mut ::std::os::raw::c_void,
                                               size: size_t,
                                               alignment: size_t,
                                               allocationScope:
                                                   VkSystemAllocationScope)
                              -> *mut ::std::os::raw::c_void>;
pub type PFN_vkReallocationFunction =
    ::std::option::Option<unsafe extern "C" fn(pUserData:
                                                   *mut ::std::os::raw::c_void,
                                               pOriginal:
                                                   *mut ::std::os::raw::c_void,
                                               size: size_t,
                                               alignment: size_t,
                                               allocationScope:
                                                   VkSystemAllocationScope)
                              -> *mut ::std::os::raw::c_void>;
pub type PFN_vkFreeFunction =
    ::std::option::Option<unsafe extern "C" fn(pUserData:
                                                   *mut ::std::os::raw::c_void,
                                               pMemory:
                                                   *mut ::std::os::raw::c_void)>;
pub type PFN_vkInternalAllocationNotification =
    ::std::option::Option<unsafe extern "C" fn(pUserData:
                                                   *mut ::std::os::raw::c_void,
                                               size: size_t,
                                               allocationType:
                                                   VkInternalAllocationType,
                                               allocationScope:
                                                   VkSystemAllocationScope)>;
pub type PFN_vkInternalFreeNotification =
    ::std::option::Option<unsafe extern "C" fn(pUserData:
                                                   *mut ::std::os::raw::c_void,
                                               size: size_t,
                                               allocationType:
                                                   VkInternalAllocationType,
                                               allocationScope:
                                                   VkSystemAllocationScope)>;
pub type PFN_vkVoidFunction = ::std::option::Option<extern "C" fn()>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkApplicationInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub pApplicationName: *const ::std::os::raw::c_char,
    pub applicationVersion: uint32_t,
    pub pEngineName: *const ::std::os::raw::c_char,
    pub engineVersion: uint32_t,
    pub apiVersion: uint32_t,
}
impl ::std::clone::Clone for Struct_VkApplicationInfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkApplicationInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkApplicationInfo = Struct_VkApplicationInfo;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkInstanceCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkInstanceCreateFlags,
    pub pApplicationInfo: *const VkApplicationInfo,
    pub enabledLayerCount: uint32_t,
    pub ppEnabledLayerNames: *const *const ::std::os::raw::c_char,
    pub enabledExtensionCount: uint32_t,
    pub ppEnabledExtensionNames: *const *const ::std::os::raw::c_char,
}
impl ::std::clone::Clone for Struct_VkInstanceCreateInfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkInstanceCreateInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkInstanceCreateInfo = Struct_VkInstanceCreateInfo;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkAllocationCallbacks {
    pub pUserData: *mut ::std::os::raw::c_void,
    pub pfnAllocation: PFN_vkAllocationFunction,
    pub pfnReallocation: PFN_vkReallocationFunction,
    pub pfnFree: PFN_vkFreeFunction,
    pub pfnInternalAllocation: PFN_vkInternalAllocationNotification,
    pub pfnInternalFree: PFN_vkInternalFreeNotification,
}
impl ::std::clone::Clone for Struct_VkAllocationCallbacks {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkAllocationCallbacks {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkAllocationCallbacks = Struct_VkAllocationCallbacks;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkPhysicalDeviceFeatures {
    pub robustBufferAccess: VkBool32,
    pub fullDrawIndexUint32: VkBool32,
    pub imageCubeArray: VkBool32,
    pub independentBlend: VkBool32,
    pub geometryShader: VkBool32,
    pub tessellationShader: VkBool32,
    pub sampleRateShading: VkBool32,
    pub dualSrcBlend: VkBool32,
    pub logicOp: VkBool32,
    pub multiDrawIndirect: VkBool32,
    pub drawIndirectFirstInstance: VkBool32,
    pub depthClamp: VkBool32,
    pub depthBiasClamp: VkBool32,
    pub fillModeNonSolid: VkBool32,
    pub depthBounds: VkBool32,
    pub wideLines: VkBool32,
    pub largePoints: VkBool32,
    pub alphaToOne: VkBool32,
    pub multiViewport: VkBool32,
    pub samplerAnisotropy: VkBool32,
    pub textureCompressionETC2: VkBool32,
    pub textureCompressionASTC_LDR: VkBool32,
    pub textureCompressionBC: VkBool32,
    pub occlusionQueryPrecise: VkBool32,
    pub pipelineStatisticsQuery: VkBool32,
    pub vertexPipelineStoresAndAtomics: VkBool32,
    pub fragmentStoresAndAtomics: VkBool32,
    pub shaderTessellationAndGeometryPointSize: VkBool32,
    pub shaderImageGatherExtended: VkBool32,
    pub shaderStorageImageExtendedFormats: VkBool32,
    pub shaderStorageImageMultisample: VkBool32,
    pub shaderStorageImageReadWithoutFormat: VkBool32,
    pub shaderStorageImageWriteWithoutFormat: VkBool32,
    pub shaderUniformBufferArrayDynamicIndexing: VkBool32,
    pub shaderSampledImageArrayDynamicIndexing: VkBool32,
    pub shaderStorageBufferArrayDynamicIndexing: VkBool32,
    pub shaderStorageImageArrayDynamicIndexing: VkBool32,
    pub shaderClipDistance: VkBool32,
    pub shaderCullDistance: VkBool32,
    pub shaderFloat64: VkBool32,
    pub shaderInt64: VkBool32,
    pub shaderInt16: VkBool32,
    pub shaderResourceResidency: VkBool32,
    pub shaderResourceMinLod: VkBool32,
    pub sparseBinding: VkBool32,
    pub sparseResidencyBuffer: VkBool32,
    pub sparseResidencyImage2D: VkBool32,
    pub sparseResidencyImage3D: VkBool32,
    pub sparseResidency2Samples: VkBool32,
    pub sparseResidency4Samples: VkBool32,
    pub sparseResidency8Samples: VkBool32,
    pub sparseResidency16Samples: VkBool32,
    pub sparseResidencyAliased: VkBool32,
    pub variableMultisampleRate: VkBool32,
    pub inheritedQueries: VkBool32,
}
impl ::std::clone::Clone for Struct_VkPhysicalDeviceFeatures {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkPhysicalDeviceFeatures {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkPhysicalDeviceFeatures = Struct_VkPhysicalDeviceFeatures;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkFormatProperties {
    pub linearTilingFeatures: VkFormatFeatureFlags,
    pub optimalTilingFeatures: VkFormatFeatureFlags,
    pub bufferFeatures: VkFormatFeatureFlags,
}
impl ::std::clone::Clone for Struct_VkFormatProperties {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkFormatProperties {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkFormatProperties = Struct_VkFormatProperties;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkExtent3D {
    pub width: uint32_t,
    pub height: uint32_t,
    pub depth: uint32_t,
}
impl ::std::clone::Clone for Struct_VkExtent3D {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkExtent3D {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkExtent3D = Struct_VkExtent3D;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkImageFormatProperties {
    pub maxExtent: VkExtent3D,
    pub maxMipLevels: uint32_t,
    pub maxArrayLayers: uint32_t,
    pub sampleCounts: VkSampleCountFlags,
    pub maxResourceSize: VkDeviceSize,
}
impl ::std::clone::Clone for Struct_VkImageFormatProperties {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkImageFormatProperties {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkImageFormatProperties = Struct_VkImageFormatProperties;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkPhysicalDeviceLimits {
    pub maxImageDimension1D: uint32_t,
    pub maxImageDimension2D: uint32_t,
    pub maxImageDimension3D: uint32_t,
    pub maxImageDimensionCube: uint32_t,
    pub maxImageArrayLayers: uint32_t,
    pub maxTexelBufferElements: uint32_t,
    pub maxUniformBufferRange: uint32_t,
    pub maxStorageBufferRange: uint32_t,
    pub maxPushConstantsSize: uint32_t,
    pub maxMemoryAllocationCount: uint32_t,
    pub maxSamplerAllocationCount: uint32_t,
    pub bufferImageGranularity: VkDeviceSize,
    pub sparseAddressSpaceSize: VkDeviceSize,
    pub maxBoundDescriptorSets: uint32_t,
    pub maxPerStageDescriptorSamplers: uint32_t,
    pub maxPerStageDescriptorUniformBuffers: uint32_t,
    pub maxPerStageDescriptorStorageBuffers: uint32_t,
    pub maxPerStageDescriptorSampledImages: uint32_t,
    pub maxPerStageDescriptorStorageImages: uint32_t,
    pub maxPerStageDescriptorInputAttachments: uint32_t,
    pub maxPerStageResources: uint32_t,
    pub maxDescriptorSetSamplers: uint32_t,
    pub maxDescriptorSetUniformBuffers: uint32_t,
    pub maxDescriptorSetUniformBuffersDynamic: uint32_t,
    pub maxDescriptorSetStorageBuffers: uint32_t,
    pub maxDescriptorSetStorageBuffersDynamic: uint32_t,
    pub maxDescriptorSetSampledImages: uint32_t,
    pub maxDescriptorSetStorageImages: uint32_t,
    pub maxDescriptorSetInputAttachments: uint32_t,
    pub maxVertexInputAttributes: uint32_t,
    pub maxVertexInputBindings: uint32_t,
    pub maxVertexInputAttributeOffset: uint32_t,
    pub maxVertexInputBindingStride: uint32_t,
    pub maxVertexOutputComponents: uint32_t,
    pub maxTessellationGenerationLevel: uint32_t,
    pub maxTessellationPatchSize: uint32_t,
    pub maxTessellationControlPerVertexInputComponents: uint32_t,
    pub maxTessellationControlPerVertexOutputComponents: uint32_t,
    pub maxTessellationControlPerPatchOutputComponents: uint32_t,
    pub maxTessellationControlTotalOutputComponents: uint32_t,
    pub maxTessellationEvaluationInputComponents: uint32_t,
    pub maxTessellationEvaluationOutputComponents: uint32_t,
    pub maxGeometryShaderInvocations: uint32_t,
    pub maxGeometryInputComponents: uint32_t,
    pub maxGeometryOutputComponents: uint32_t,
    pub maxGeometryOutputVertices: uint32_t,
    pub maxGeometryTotalOutputComponents: uint32_t,
    pub maxFragmentInputComponents: uint32_t,
    pub maxFragmentOutputAttachments: uint32_t,
    pub maxFragmentDualSrcAttachments: uint32_t,
    pub maxFragmentCombinedOutputResources: uint32_t,
    pub maxComputeSharedMemorySize: uint32_t,
    pub maxComputeWorkGroupCount: [uint32_t; 3usize],
    pub maxComputeWorkGroupInvocations: uint32_t,
    pub maxComputeWorkGroupSize: [uint32_t; 3usize],
    pub subPixelPrecisionBits: uint32_t,
    pub subTexelPrecisionBits: uint32_t,
    pub mipmapPrecisionBits: uint32_t,
    pub maxDrawIndexedIndexValue: uint32_t,
    pub maxDrawIndirectCount: uint32_t,
    pub maxSamplerLodBias: ::std::os::raw::c_float,
    pub maxSamplerAnisotropy: ::std::os::raw::c_float,
    pub maxViewports: uint32_t,
    pub maxViewportDimensions: [uint32_t; 2usize],
    pub viewportBoundsRange: [::std::os::raw::c_float; 2usize],
    pub viewportSubPixelBits: uint32_t,
    pub minMemoryMapAlignment: size_t,
    pub minTexelBufferOffsetAlignment: VkDeviceSize,
    pub minUniformBufferOffsetAlignment: VkDeviceSize,
    pub minStorageBufferOffsetAlignment: VkDeviceSize,
    pub minTexelOffset: int32_t,
    pub maxTexelOffset: uint32_t,
    pub minTexelGatherOffset: int32_t,
    pub maxTexelGatherOffset: uint32_t,
    pub minInterpolationOffset: ::std::os::raw::c_float,
    pub maxInterpolationOffset: ::std::os::raw::c_float,
    pub subPixelInterpolationOffsetBits: uint32_t,
    pub maxFramebufferWidth: uint32_t,
    pub maxFramebufferHeight: uint32_t,
    pub maxFramebufferLayers: uint32_t,
    pub framebufferColorSampleCounts: VkSampleCountFlags,
    pub framebufferDepthSampleCounts: VkSampleCountFlags,
    pub framebufferStencilSampleCounts: VkSampleCountFlags,
    pub framebufferNoAttachmentsSampleCounts: VkSampleCountFlags,
    pub maxColorAttachments: uint32_t,
    pub sampledImageColorSampleCounts: VkSampleCountFlags,
    pub sampledImageIntegerSampleCounts: VkSampleCountFlags,
    pub sampledImageDepthSampleCounts: VkSampleCountFlags,
    pub sampledImageStencilSampleCounts: VkSampleCountFlags,
    pub storageImageSampleCounts: VkSampleCountFlags,
    pub maxSampleMaskWords: uint32_t,
    pub timestampComputeAndGraphics: VkBool32,
    pub timestampPeriod: ::std::os::raw::c_float,
    pub maxClipDistances: uint32_t,
    pub maxCullDistances: uint32_t,
    pub maxCombinedClipAndCullDistances: uint32_t,
    pub discreteQueuePriorities: uint32_t,
    pub pointSizeRange: [::std::os::raw::c_float; 2usize],
    pub lineWidthRange: [::std::os::raw::c_float; 2usize],
    pub pointSizeGranularity: ::std::os::raw::c_float,
    pub lineWidthGranularity: ::std::os::raw::c_float,
    pub strictLines: VkBool32,
    pub standardSampleLocations: VkBool32,
    pub optimalBufferCopyOffsetAlignment: VkDeviceSize,
    pub optimalBufferCopyRowPitchAlignment: VkDeviceSize,
    pub nonCoherentAtomSize: VkDeviceSize,
}
impl ::std::clone::Clone for Struct_VkPhysicalDeviceLimits {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkPhysicalDeviceLimits {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkPhysicalDeviceLimits = Struct_VkPhysicalDeviceLimits;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkPhysicalDeviceSparseProperties {
    pub residencyStandard2DBlockShape: VkBool32,
    pub residencyStandard2DMultisampleBlockShape: VkBool32,
    pub residencyStandard3DBlockShape: VkBool32,
    pub residencyAlignedMipSize: VkBool32,
    pub residencyNonResidentStrict: VkBool32,
}
impl ::std::clone::Clone for Struct_VkPhysicalDeviceSparseProperties {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkPhysicalDeviceSparseProperties {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkPhysicalDeviceSparseProperties =
    Struct_VkPhysicalDeviceSparseProperties;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkPhysicalDeviceProperties {
    pub apiVersion: uint32_t,
    pub driverVersion: uint32_t,
    pub vendorID: uint32_t,
    pub deviceID: uint32_t,
    pub deviceType: VkPhysicalDeviceType,
    pub deviceName: [::std::os::raw::c_char; 256usize],
    pub pipelineCacheUUID: [uint8_t; 16usize],
    pub limits: VkPhysicalDeviceLimits,
    pub sparseProperties: VkPhysicalDeviceSparseProperties,
}
impl ::std::clone::Clone for Struct_VkPhysicalDeviceProperties {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkPhysicalDeviceProperties {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkPhysicalDeviceProperties = Struct_VkPhysicalDeviceProperties;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkQueueFamilyProperties {
    pub queueFlags: VkQueueFlags,
    pub queueCount: uint32_t,
    pub timestampValidBits: uint32_t,
    pub minImageTransferGranularity: VkExtent3D,
}
impl ::std::clone::Clone for Struct_VkQueueFamilyProperties {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkQueueFamilyProperties {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkQueueFamilyProperties = Struct_VkQueueFamilyProperties;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkMemoryType {
    pub propertyFlags: VkMemoryPropertyFlags,
    pub heapIndex: uint32_t,
}
impl ::std::clone::Clone for Struct_VkMemoryType {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkMemoryType {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkMemoryType = Struct_VkMemoryType;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkMemoryHeap {
    pub size: VkDeviceSize,
    pub flags: VkMemoryHeapFlags,
}
impl ::std::clone::Clone for Struct_VkMemoryHeap {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkMemoryHeap {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkMemoryHeap = Struct_VkMemoryHeap;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkPhysicalDeviceMemoryProperties {
    pub memoryTypeCount: uint32_t,
    pub memoryTypes: [VkMemoryType; 32usize],
    pub memoryHeapCount: uint32_t,
    pub memoryHeaps: [VkMemoryHeap; 16usize],
}
impl ::std::clone::Clone for Struct_VkPhysicalDeviceMemoryProperties {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkPhysicalDeviceMemoryProperties {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkPhysicalDeviceMemoryProperties =
    Struct_VkPhysicalDeviceMemoryProperties;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkDeviceQueueCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkDeviceQueueCreateFlags,
    pub queueFamilyIndex: uint32_t,
    pub queueCount: uint32_t,
    pub pQueuePriorities: *const ::std::os::raw::c_float,
}
impl ::std::clone::Clone for Struct_VkDeviceQueueCreateInfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkDeviceQueueCreateInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkDeviceQueueCreateInfo = Struct_VkDeviceQueueCreateInfo;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkDeviceCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkDeviceCreateFlags,
    pub queueCreateInfoCount: uint32_t,
    pub pQueueCreateInfos: *const VkDeviceQueueCreateInfo,
    pub enabledLayerCount: uint32_t,
    pub ppEnabledLayerNames: *const *const ::std::os::raw::c_char,
    pub enabledExtensionCount: uint32_t,
    pub ppEnabledExtensionNames: *const *const ::std::os::raw::c_char,
    pub pEnabledFeatures: *const VkPhysicalDeviceFeatures,
}
impl ::std::clone::Clone for Struct_VkDeviceCreateInfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkDeviceCreateInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkDeviceCreateInfo = Struct_VkDeviceCreateInfo;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkExtensionProperties {
    pub extensionName: [::std::os::raw::c_char; 256usize],
    pub specVersion: uint32_t,
}
impl ::std::clone::Clone for Struct_VkExtensionProperties {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkExtensionProperties {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkExtensionProperties = Struct_VkExtensionProperties;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkLayerProperties {
    pub layerName: [::std::os::raw::c_char; 256usize],
    pub specVersion: uint32_t,
    pub implementationVersion: uint32_t,
    pub description: [::std::os::raw::c_char; 256usize],
}
impl ::std::clone::Clone for Struct_VkLayerProperties {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkLayerProperties {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkLayerProperties = Struct_VkLayerProperties;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkSubmitInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub waitSemaphoreCount: uint32_t,
    pub pWaitSemaphores: *const VkSemaphore,
    pub pWaitDstStageMask: *const VkPipelineStageFlags,
    pub commandBufferCount: uint32_t,
    pub pCommandBuffers: *const VkCommandBuffer,
    pub signalSemaphoreCount: uint32_t,
    pub pSignalSemaphores: *const VkSemaphore,
}
impl ::std::clone::Clone for Struct_VkSubmitInfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkSubmitInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkSubmitInfo = Struct_VkSubmitInfo;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkMemoryAllocateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub allocationSize: VkDeviceSize,
    pub memoryTypeIndex: uint32_t,
}
impl ::std::clone::Clone for Struct_VkMemoryAllocateInfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkMemoryAllocateInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkMemoryAllocateInfo = Struct_VkMemoryAllocateInfo;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkMappedMemoryRange {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub memory: VkDeviceMemory,
    pub offset: VkDeviceSize,
    pub size: VkDeviceSize,
}
impl ::std::clone::Clone for Struct_VkMappedMemoryRange {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkMappedMemoryRange {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkMappedMemoryRange = Struct_VkMappedMemoryRange;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkMemoryRequirements {
    pub size: VkDeviceSize,
    pub alignment: VkDeviceSize,
    pub memoryTypeBits: uint32_t,
}
impl ::std::clone::Clone for Struct_VkMemoryRequirements {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkMemoryRequirements {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkMemoryRequirements = Struct_VkMemoryRequirements;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkSparseImageFormatProperties {
    pub aspectMask: VkImageAspectFlags,
    pub imageGranularity: VkExtent3D,
    pub flags: VkSparseImageFormatFlags,
}
impl ::std::clone::Clone for Struct_VkSparseImageFormatProperties {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkSparseImageFormatProperties {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkSparseImageFormatProperties = Struct_VkSparseImageFormatProperties;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkSparseImageMemoryRequirements {
    pub formatProperties: VkSparseImageFormatProperties,
    pub imageMipTailFirstLod: uint32_t,
    pub imageMipTailSize: VkDeviceSize,
    pub imageMipTailOffset: VkDeviceSize,
    pub imageMipTailStride: VkDeviceSize,
}
impl ::std::clone::Clone for Struct_VkSparseImageMemoryRequirements {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkSparseImageMemoryRequirements {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkSparseImageMemoryRequirements =
    Struct_VkSparseImageMemoryRequirements;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkSparseMemoryBind {
    pub resourceOffset: VkDeviceSize,
    pub size: VkDeviceSize,
    pub memory: VkDeviceMemory,
    pub memoryOffset: VkDeviceSize,
    pub flags: VkSparseMemoryBindFlags,
}
impl ::std::clone::Clone for Struct_VkSparseMemoryBind {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkSparseMemoryBind {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkSparseMemoryBind = Struct_VkSparseMemoryBind;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkSparseBufferMemoryBindInfo {
    pub buffer: VkBuffer,
    pub bindCount: uint32_t,
    pub pBinds: *const VkSparseMemoryBind,
}
impl ::std::clone::Clone for Struct_VkSparseBufferMemoryBindInfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkSparseBufferMemoryBindInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkSparseBufferMemoryBindInfo = Struct_VkSparseBufferMemoryBindInfo;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkSparseImageOpaqueMemoryBindInfo {
    pub image: VkImage,
    pub bindCount: uint32_t,
    pub pBinds: *const VkSparseMemoryBind,
}
impl ::std::clone::Clone for Struct_VkSparseImageOpaqueMemoryBindInfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkSparseImageOpaqueMemoryBindInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkSparseImageOpaqueMemoryBindInfo =
    Struct_VkSparseImageOpaqueMemoryBindInfo;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkImageSubresource {
    pub aspectMask: VkImageAspectFlags,
    pub mipLevel: uint32_t,
    pub arrayLayer: uint32_t,
}
impl ::std::clone::Clone for Struct_VkImageSubresource {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkImageSubresource {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkImageSubresource = Struct_VkImageSubresource;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkOffset3D {
    pub x: int32_t,
    pub y: int32_t,
    pub z: int32_t,
}
impl ::std::clone::Clone for Struct_VkOffset3D {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkOffset3D {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkOffset3D = Struct_VkOffset3D;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkSparseImageMemoryBind {
    pub subresource: VkImageSubresource,
    pub offset: VkOffset3D,
    pub extent: VkExtent3D,
    pub memory: VkDeviceMemory,
    pub memoryOffset: VkDeviceSize,
    pub flags: VkSparseMemoryBindFlags,
}
impl ::std::clone::Clone for Struct_VkSparseImageMemoryBind {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkSparseImageMemoryBind {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkSparseImageMemoryBind = Struct_VkSparseImageMemoryBind;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkSparseImageMemoryBindInfo {
    pub image: VkImage,
    pub bindCount: uint32_t,
    pub pBinds: *const VkSparseImageMemoryBind,
}
impl ::std::clone::Clone for Struct_VkSparseImageMemoryBindInfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkSparseImageMemoryBindInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkSparseImageMemoryBindInfo = Struct_VkSparseImageMemoryBindInfo;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkBindSparseInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub waitSemaphoreCount: uint32_t,
    pub pWaitSemaphores: *const VkSemaphore,
    pub bufferBindCount: uint32_t,
    pub pBufferBinds: *const VkSparseBufferMemoryBindInfo,
    pub imageOpaqueBindCount: uint32_t,
    pub pImageOpaqueBinds: *const VkSparseImageOpaqueMemoryBindInfo,
    pub imageBindCount: uint32_t,
    pub pImageBinds: *const VkSparseImageMemoryBindInfo,
    pub signalSemaphoreCount: uint32_t,
    pub pSignalSemaphores: *const VkSemaphore,
}
impl ::std::clone::Clone for Struct_VkBindSparseInfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkBindSparseInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkBindSparseInfo = Struct_VkBindSparseInfo;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkFenceCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkFenceCreateFlags,
}
impl ::std::clone::Clone for Struct_VkFenceCreateInfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkFenceCreateInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkFenceCreateInfo = Struct_VkFenceCreateInfo;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkSemaphoreCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkSemaphoreCreateFlags,
}
impl ::std::clone::Clone for Struct_VkSemaphoreCreateInfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkSemaphoreCreateInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkSemaphoreCreateInfo = Struct_VkSemaphoreCreateInfo;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkEventCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkEventCreateFlags,
}
impl ::std::clone::Clone for Struct_VkEventCreateInfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkEventCreateInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkEventCreateInfo = Struct_VkEventCreateInfo;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkQueryPoolCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkQueryPoolCreateFlags,
    pub queryType: VkQueryType,
    pub queryCount: uint32_t,
    pub pipelineStatistics: VkQueryPipelineStatisticFlags,
}
impl ::std::clone::Clone for Struct_VkQueryPoolCreateInfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkQueryPoolCreateInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkQueryPoolCreateInfo = Struct_VkQueryPoolCreateInfo;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkBufferCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkBufferCreateFlags,
    pub size: VkDeviceSize,
    pub usage: VkBufferUsageFlags,
    pub sharingMode: VkSharingMode,
    pub queueFamilyIndexCount: uint32_t,
    pub pQueueFamilyIndices: *const uint32_t,
}
impl ::std::clone::Clone for Struct_VkBufferCreateInfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkBufferCreateInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkBufferCreateInfo = Struct_VkBufferCreateInfo;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkBufferViewCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkBufferViewCreateFlags,
    pub buffer: VkBuffer,
    pub format: VkFormat,
    pub offset: VkDeviceSize,
    pub range: VkDeviceSize,
}
impl ::std::clone::Clone for Struct_VkBufferViewCreateInfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkBufferViewCreateInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkBufferViewCreateInfo = Struct_VkBufferViewCreateInfo;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkImageCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkImageCreateFlags,
    pub imageType: VkImageType,
    pub format: VkFormat,
    pub extent: VkExtent3D,
    pub mipLevels: uint32_t,
    pub arrayLayers: uint32_t,
    pub samples: VkSampleCountFlagBits,
    pub tiling: VkImageTiling,
    pub usage: VkImageUsageFlags,
    pub sharingMode: VkSharingMode,
    pub queueFamilyIndexCount: uint32_t,
    pub pQueueFamilyIndices: *const uint32_t,
    pub initialLayout: VkImageLayout,
}
impl ::std::clone::Clone for Struct_VkImageCreateInfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkImageCreateInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkImageCreateInfo = Struct_VkImageCreateInfo;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkSubresourceLayout {
    pub offset: VkDeviceSize,
    pub size: VkDeviceSize,
    pub rowPitch: VkDeviceSize,
    pub arrayPitch: VkDeviceSize,
    pub depthPitch: VkDeviceSize,
}
impl ::std::clone::Clone for Struct_VkSubresourceLayout {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkSubresourceLayout {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkSubresourceLayout = Struct_VkSubresourceLayout;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkComponentMapping {
    pub r: VkComponentSwizzle,
    pub g: VkComponentSwizzle,
    pub b: VkComponentSwizzle,
    pub a: VkComponentSwizzle,
}
impl ::std::clone::Clone for Struct_VkComponentMapping {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkComponentMapping {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkComponentMapping = Struct_VkComponentMapping;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkImageSubresourceRange {
    pub aspectMask: VkImageAspectFlags,
    pub baseMipLevel: uint32_t,
    pub levelCount: uint32_t,
    pub baseArrayLayer: uint32_t,
    pub layerCount: uint32_t,
}
impl ::std::clone::Clone for Struct_VkImageSubresourceRange {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkImageSubresourceRange {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkImageSubresourceRange = Struct_VkImageSubresourceRange;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkImageViewCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkImageViewCreateFlags,
    pub image: VkImage,
    pub viewType: VkImageViewType,
    pub format: VkFormat,
    pub components: VkComponentMapping,
    pub subresourceRange: VkImageSubresourceRange,
}
impl ::std::clone::Clone for Struct_VkImageViewCreateInfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkImageViewCreateInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkImageViewCreateInfo = Struct_VkImageViewCreateInfo;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkShaderModuleCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkShaderModuleCreateFlags,
    pub codeSize: size_t,
    pub pCode: *const uint32_t,
}
impl ::std::clone::Clone for Struct_VkShaderModuleCreateInfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkShaderModuleCreateInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkShaderModuleCreateInfo = Struct_VkShaderModuleCreateInfo;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkPipelineCacheCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineCacheCreateFlags,
    pub initialDataSize: size_t,
    pub pInitialData: *const ::std::os::raw::c_void,
}
impl ::std::clone::Clone for Struct_VkPipelineCacheCreateInfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkPipelineCacheCreateInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkPipelineCacheCreateInfo = Struct_VkPipelineCacheCreateInfo;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkSpecializationMapEntry {
    pub constantID: uint32_t,
    pub offset: uint32_t,
    pub size: size_t,
}
impl ::std::clone::Clone for Struct_VkSpecializationMapEntry {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkSpecializationMapEntry {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkSpecializationMapEntry = Struct_VkSpecializationMapEntry;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkSpecializationInfo {
    pub mapEntryCount: uint32_t,
    pub pMapEntries: *const VkSpecializationMapEntry,
    pub dataSize: size_t,
    pub pData: *const ::std::os::raw::c_void,
}
impl ::std::clone::Clone for Struct_VkSpecializationInfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkSpecializationInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkSpecializationInfo = Struct_VkSpecializationInfo;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkPipelineShaderStageCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineShaderStageCreateFlags,
    pub stage: VkShaderStageFlagBits,
    pub module: VkShaderModule,
    pub pName: *const ::std::os::raw::c_char,
    pub pSpecializationInfo: *const VkSpecializationInfo,
}
impl ::std::clone::Clone for Struct_VkPipelineShaderStageCreateInfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkPipelineShaderStageCreateInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkPipelineShaderStageCreateInfo =
    Struct_VkPipelineShaderStageCreateInfo;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkVertexInputBindingDescription {
    pub binding: uint32_t,
    pub stride: uint32_t,
    pub inputRate: VkVertexInputRate,
}
impl ::std::clone::Clone for Struct_VkVertexInputBindingDescription {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkVertexInputBindingDescription {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkVertexInputBindingDescription =
    Struct_VkVertexInputBindingDescription;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkVertexInputAttributeDescription {
    pub location: uint32_t,
    pub binding: uint32_t,
    pub format: VkFormat,
    pub offset: uint32_t,
}
impl ::std::clone::Clone for Struct_VkVertexInputAttributeDescription {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkVertexInputAttributeDescription {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkVertexInputAttributeDescription =
    Struct_VkVertexInputAttributeDescription;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkPipelineVertexInputStateCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineVertexInputStateCreateFlags,
    pub vertexBindingDescriptionCount: uint32_t,
    pub pVertexBindingDescriptions: *const VkVertexInputBindingDescription,
    pub vertexAttributeDescriptionCount: uint32_t,
    pub pVertexAttributeDescriptions: *const VkVertexInputAttributeDescription,
}
impl ::std::clone::Clone for Struct_VkPipelineVertexInputStateCreateInfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkPipelineVertexInputStateCreateInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkPipelineVertexInputStateCreateInfo =
    Struct_VkPipelineVertexInputStateCreateInfo;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkPipelineInputAssemblyStateCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineInputAssemblyStateCreateFlags,
    pub topology: VkPrimitiveTopology,
    pub primitiveRestartEnable: VkBool32,
}
impl ::std::clone::Clone for Struct_VkPipelineInputAssemblyStateCreateInfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkPipelineInputAssemblyStateCreateInfo
 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkPipelineInputAssemblyStateCreateInfo =
    Struct_VkPipelineInputAssemblyStateCreateInfo;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkPipelineTessellationStateCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineTessellationStateCreateFlags,
    pub patchControlPoints: uint32_t,
}
impl ::std::clone::Clone for Struct_VkPipelineTessellationStateCreateInfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkPipelineTessellationStateCreateInfo
 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkPipelineTessellationStateCreateInfo =
    Struct_VkPipelineTessellationStateCreateInfo;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkViewport {
    pub x: ::std::os::raw::c_float,
    pub y: ::std::os::raw::c_float,
    pub width: ::std::os::raw::c_float,
    pub height: ::std::os::raw::c_float,
    pub minDepth: ::std::os::raw::c_float,
    pub maxDepth: ::std::os::raw::c_float,
}
impl ::std::clone::Clone for Struct_VkViewport {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkViewport {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkViewport = Struct_VkViewport;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkOffset2D {
    pub x: int32_t,
    pub y: int32_t,
}
impl ::std::clone::Clone for Struct_VkOffset2D {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkOffset2D {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkOffset2D = Struct_VkOffset2D;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkExtent2D {
    pub width: uint32_t,
    pub height: uint32_t,
}
impl ::std::clone::Clone for Struct_VkExtent2D {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkExtent2D {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkExtent2D = Struct_VkExtent2D;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkRect2D {
    pub offset: VkOffset2D,
    pub extent: VkExtent2D,
}
impl ::std::clone::Clone for Struct_VkRect2D {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkRect2D {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkRect2D = Struct_VkRect2D;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkPipelineViewportStateCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineViewportStateCreateFlags,
    pub viewportCount: uint32_t,
    pub pViewports: *const VkViewport,
    pub scissorCount: uint32_t,
    pub pScissors: *const VkRect2D,
}
impl ::std::clone::Clone for Struct_VkPipelineViewportStateCreateInfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkPipelineViewportStateCreateInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkPipelineViewportStateCreateInfo =
    Struct_VkPipelineViewportStateCreateInfo;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkPipelineRasterizationStateCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineRasterizationStateCreateFlags,
    pub depthClampEnable: VkBool32,
    pub rasterizerDiscardEnable: VkBool32,
    pub polygonMode: VkPolygonMode,
    pub cullMode: VkCullModeFlags,
    pub frontFace: VkFrontFace,
    pub depthBiasEnable: VkBool32,
    pub depthBiasConstantFactor: ::std::os::raw::c_float,
    pub depthBiasClamp: ::std::os::raw::c_float,
    pub depthBiasSlopeFactor: ::std::os::raw::c_float,
    pub lineWidth: ::std::os::raw::c_float,
}
impl ::std::clone::Clone for Struct_VkPipelineRasterizationStateCreateInfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkPipelineRasterizationStateCreateInfo
 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkPipelineRasterizationStateCreateInfo =
    Struct_VkPipelineRasterizationStateCreateInfo;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkPipelineMultisampleStateCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineMultisampleStateCreateFlags,
    pub rasterizationSamples: VkSampleCountFlagBits,
    pub sampleShadingEnable: VkBool32,
    pub minSampleShading: ::std::os::raw::c_float,
    pub pSampleMask: *const VkSampleMask,
    pub alphaToCoverageEnable: VkBool32,
    pub alphaToOneEnable: VkBool32,
}
impl ::std::clone::Clone for Struct_VkPipelineMultisampleStateCreateInfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkPipelineMultisampleStateCreateInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkPipelineMultisampleStateCreateInfo =
    Struct_VkPipelineMultisampleStateCreateInfo;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkStencilOpState {
    pub failOp: VkStencilOp,
    pub passOp: VkStencilOp,
    pub depthFailOp: VkStencilOp,
    pub compareOp: VkCompareOp,
    pub compareMask: uint32_t,
    pub writeMask: uint32_t,
    pub reference: uint32_t,
}
impl ::std::clone::Clone for Struct_VkStencilOpState {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkStencilOpState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkStencilOpState = Struct_VkStencilOpState;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkPipelineDepthStencilStateCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineDepthStencilStateCreateFlags,
    pub depthTestEnable: VkBool32,
    pub depthWriteEnable: VkBool32,
    pub depthCompareOp: VkCompareOp,
    pub depthBoundsTestEnable: VkBool32,
    pub stencilTestEnable: VkBool32,
    pub front: VkStencilOpState,
    pub back: VkStencilOpState,
    pub minDepthBounds: ::std::os::raw::c_float,
    pub maxDepthBounds: ::std::os::raw::c_float,
}
impl ::std::clone::Clone for Struct_VkPipelineDepthStencilStateCreateInfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkPipelineDepthStencilStateCreateInfo
 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkPipelineDepthStencilStateCreateInfo =
    Struct_VkPipelineDepthStencilStateCreateInfo;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkPipelineColorBlendAttachmentState {
    pub blendEnable: VkBool32,
    pub srcColorBlendFactor: VkBlendFactor,
    pub dstColorBlendFactor: VkBlendFactor,
    pub colorBlendOp: VkBlendOp,
    pub srcAlphaBlendFactor: VkBlendFactor,
    pub dstAlphaBlendFactor: VkBlendFactor,
    pub alphaBlendOp: VkBlendOp,
    pub colorWriteMask: VkColorComponentFlags,
}
impl ::std::clone::Clone for Struct_VkPipelineColorBlendAttachmentState {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkPipelineColorBlendAttachmentState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkPipelineColorBlendAttachmentState =
    Struct_VkPipelineColorBlendAttachmentState;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkPipelineColorBlendStateCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineColorBlendStateCreateFlags,
    pub logicOpEnable: VkBool32,
    pub logicOp: VkLogicOp,
    pub attachmentCount: uint32_t,
    pub pAttachments: *const VkPipelineColorBlendAttachmentState,
    pub blendConstants: [::std::os::raw::c_float; 4usize],
}
impl ::std::clone::Clone for Struct_VkPipelineColorBlendStateCreateInfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkPipelineColorBlendStateCreateInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkPipelineColorBlendStateCreateInfo =
    Struct_VkPipelineColorBlendStateCreateInfo;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkPipelineDynamicStateCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineDynamicStateCreateFlags,
    pub dynamicStateCount: uint32_t,
    pub pDynamicStates: *const VkDynamicState,
}
impl ::std::clone::Clone for Struct_VkPipelineDynamicStateCreateInfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkPipelineDynamicStateCreateInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkPipelineDynamicStateCreateInfo =
    Struct_VkPipelineDynamicStateCreateInfo;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkGraphicsPipelineCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineCreateFlags,
    pub stageCount: uint32_t,
    pub pStages: *const VkPipelineShaderStageCreateInfo,
    pub pVertexInputState: *const VkPipelineVertexInputStateCreateInfo,
    pub pInputAssemblyState: *const VkPipelineInputAssemblyStateCreateInfo,
    pub pTessellationState: *const VkPipelineTessellationStateCreateInfo,
    pub pViewportState: *const VkPipelineViewportStateCreateInfo,
    pub pRasterizationState: *const VkPipelineRasterizationStateCreateInfo,
    pub pMultisampleState: *const VkPipelineMultisampleStateCreateInfo,
    pub pDepthStencilState: *const VkPipelineDepthStencilStateCreateInfo,
    pub pColorBlendState: *const VkPipelineColorBlendStateCreateInfo,
    pub pDynamicState: *const VkPipelineDynamicStateCreateInfo,
    pub layout: VkPipelineLayout,
    pub renderPass: VkRenderPass,
    pub subpass: uint32_t,
    pub basePipelineHandle: VkPipeline,
    pub basePipelineIndex: int32_t,
}
impl ::std::clone::Clone for Struct_VkGraphicsPipelineCreateInfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkGraphicsPipelineCreateInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkGraphicsPipelineCreateInfo = Struct_VkGraphicsPipelineCreateInfo;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkComputePipelineCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineCreateFlags,
    pub stage: VkPipelineShaderStageCreateInfo,
    pub layout: VkPipelineLayout,
    pub basePipelineHandle: VkPipeline,
    pub basePipelineIndex: int32_t,
}
impl ::std::clone::Clone for Struct_VkComputePipelineCreateInfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkComputePipelineCreateInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkComputePipelineCreateInfo = Struct_VkComputePipelineCreateInfo;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkPushConstantRange {
    pub stageFlags: VkShaderStageFlags,
    pub offset: uint32_t,
    pub size: uint32_t,
}
impl ::std::clone::Clone for Struct_VkPushConstantRange {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkPushConstantRange {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkPushConstantRange = Struct_VkPushConstantRange;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkPipelineLayoutCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineLayoutCreateFlags,
    pub setLayoutCount: uint32_t,
    pub pSetLayouts: *const VkDescriptorSetLayout,
    pub pushConstantRangeCount: uint32_t,
    pub pPushConstantRanges: *const VkPushConstantRange,
}
impl ::std::clone::Clone for Struct_VkPipelineLayoutCreateInfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkPipelineLayoutCreateInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkPipelineLayoutCreateInfo = Struct_VkPipelineLayoutCreateInfo;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkSamplerCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkSamplerCreateFlags,
    pub magFilter: VkFilter,
    pub minFilter: VkFilter,
    pub mipmapMode: VkSamplerMipmapMode,
    pub addressModeU: VkSamplerAddressMode,
    pub addressModeV: VkSamplerAddressMode,
    pub addressModeW: VkSamplerAddressMode,
    pub mipLodBias: ::std::os::raw::c_float,
    pub anisotropyEnable: VkBool32,
    pub maxAnisotropy: ::std::os::raw::c_float,
    pub compareEnable: VkBool32,
    pub compareOp: VkCompareOp,
    pub minLod: ::std::os::raw::c_float,
    pub maxLod: ::std::os::raw::c_float,
    pub borderColor: VkBorderColor,
    pub unnormalizedCoordinates: VkBool32,
}
impl ::std::clone::Clone for Struct_VkSamplerCreateInfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkSamplerCreateInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkSamplerCreateInfo = Struct_VkSamplerCreateInfo;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkDescriptorSetLayoutBinding {
    pub binding: uint32_t,
    pub descriptorType: VkDescriptorType,
    pub descriptorCount: uint32_t,
    pub stageFlags: VkShaderStageFlags,
    pub pImmutableSamplers: *const VkSampler,
}
impl ::std::clone::Clone for Struct_VkDescriptorSetLayoutBinding {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkDescriptorSetLayoutBinding {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkDescriptorSetLayoutBinding = Struct_VkDescriptorSetLayoutBinding;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkDescriptorSetLayoutCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkDescriptorSetLayoutCreateFlags,
    pub bindingCount: uint32_t,
    pub pBindings: *const VkDescriptorSetLayoutBinding,
}
impl ::std::clone::Clone for Struct_VkDescriptorSetLayoutCreateInfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkDescriptorSetLayoutCreateInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkDescriptorSetLayoutCreateInfo =
    Struct_VkDescriptorSetLayoutCreateInfo;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkDescriptorPoolSize {
    pub _type: VkDescriptorType,
    pub descriptorCount: uint32_t,
}
impl ::std::clone::Clone for Struct_VkDescriptorPoolSize {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkDescriptorPoolSize {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkDescriptorPoolSize = Struct_VkDescriptorPoolSize;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkDescriptorPoolCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkDescriptorPoolCreateFlags,
    pub maxSets: uint32_t,
    pub poolSizeCount: uint32_t,
    pub pPoolSizes: *const VkDescriptorPoolSize,
}
impl ::std::clone::Clone for Struct_VkDescriptorPoolCreateInfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkDescriptorPoolCreateInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkDescriptorPoolCreateInfo = Struct_VkDescriptorPoolCreateInfo;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkDescriptorSetAllocateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub descriptorPool: VkDescriptorPool,
    pub descriptorSetCount: uint32_t,
    pub pSetLayouts: *const VkDescriptorSetLayout,
}
impl ::std::clone::Clone for Struct_VkDescriptorSetAllocateInfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkDescriptorSetAllocateInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkDescriptorSetAllocateInfo = Struct_VkDescriptorSetAllocateInfo;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkDescriptorImageInfo {
    pub sampler: VkSampler,
    pub imageView: VkImageView,
    pub imageLayout: VkImageLayout,
}
impl ::std::clone::Clone for Struct_VkDescriptorImageInfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkDescriptorImageInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkDescriptorImageInfo = Struct_VkDescriptorImageInfo;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkDescriptorBufferInfo {
    pub buffer: VkBuffer,
    pub offset: VkDeviceSize,
    pub range: VkDeviceSize,
}
impl ::std::clone::Clone for Struct_VkDescriptorBufferInfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkDescriptorBufferInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkDescriptorBufferInfo = Struct_VkDescriptorBufferInfo;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkWriteDescriptorSet {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub dstSet: VkDescriptorSet,
    pub dstBinding: uint32_t,
    pub dstArrayElement: uint32_t,
    pub descriptorCount: uint32_t,
    pub descriptorType: VkDescriptorType,
    pub pImageInfo: *const VkDescriptorImageInfo,
    pub pBufferInfo: *const VkDescriptorBufferInfo,
    pub pTexelBufferView: *const VkBufferView,
}
impl ::std::clone::Clone for Struct_VkWriteDescriptorSet {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkWriteDescriptorSet {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkWriteDescriptorSet = Struct_VkWriteDescriptorSet;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkCopyDescriptorSet {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub srcSet: VkDescriptorSet,
    pub srcBinding: uint32_t,
    pub srcArrayElement: uint32_t,
    pub dstSet: VkDescriptorSet,
    pub dstBinding: uint32_t,
    pub dstArrayElement: uint32_t,
    pub descriptorCount: uint32_t,
}
impl ::std::clone::Clone for Struct_VkCopyDescriptorSet {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkCopyDescriptorSet {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkCopyDescriptorSet = Struct_VkCopyDescriptorSet;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkFramebufferCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkFramebufferCreateFlags,
    pub renderPass: VkRenderPass,
    pub attachmentCount: uint32_t,
    pub pAttachments: *const VkImageView,
    pub width: uint32_t,
    pub height: uint32_t,
    pub layers: uint32_t,
}
impl ::std::clone::Clone for Struct_VkFramebufferCreateInfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkFramebufferCreateInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkFramebufferCreateInfo = Struct_VkFramebufferCreateInfo;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkAttachmentDescription {
    pub flags: VkAttachmentDescriptionFlags,
    pub format: VkFormat,
    pub samples: VkSampleCountFlagBits,
    pub loadOp: VkAttachmentLoadOp,
    pub storeOp: VkAttachmentStoreOp,
    pub stencilLoadOp: VkAttachmentLoadOp,
    pub stencilStoreOp: VkAttachmentStoreOp,
    pub initialLayout: VkImageLayout,
    pub finalLayout: VkImageLayout,
}
impl ::std::clone::Clone for Struct_VkAttachmentDescription {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkAttachmentDescription {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkAttachmentDescription = Struct_VkAttachmentDescription;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkAttachmentReference {
    pub attachment: uint32_t,
    pub layout: VkImageLayout,
}
impl ::std::clone::Clone for Struct_VkAttachmentReference {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkAttachmentReference {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkAttachmentReference = Struct_VkAttachmentReference;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkSubpassDescription {
    pub flags: VkSubpassDescriptionFlags,
    pub pipelineBindPoint: VkPipelineBindPoint,
    pub inputAttachmentCount: uint32_t,
    pub pInputAttachments: *const VkAttachmentReference,
    pub colorAttachmentCount: uint32_t,
    pub pColorAttachments: *const VkAttachmentReference,
    pub pResolveAttachments: *const VkAttachmentReference,
    pub pDepthStencilAttachment: *const VkAttachmentReference,
    pub preserveAttachmentCount: uint32_t,
    pub pPreserveAttachments: *const uint32_t,
}
impl ::std::clone::Clone for Struct_VkSubpassDescription {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkSubpassDescription {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkSubpassDescription = Struct_VkSubpassDescription;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkSubpassDependency {
    pub srcSubpass: uint32_t,
    pub dstSubpass: uint32_t,
    pub srcStageMask: VkPipelineStageFlags,
    pub dstStageMask: VkPipelineStageFlags,
    pub srcAccessMask: VkAccessFlags,
    pub dstAccessMask: VkAccessFlags,
    pub dependencyFlags: VkDependencyFlags,
}
impl ::std::clone::Clone for Struct_VkSubpassDependency {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkSubpassDependency {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkSubpassDependency = Struct_VkSubpassDependency;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkRenderPassCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkRenderPassCreateFlags,
    pub attachmentCount: uint32_t,
    pub pAttachments: *const VkAttachmentDescription,
    pub subpassCount: uint32_t,
    pub pSubpasses: *const VkSubpassDescription,
    pub dependencyCount: uint32_t,
    pub pDependencies: *const VkSubpassDependency,
}
impl ::std::clone::Clone for Struct_VkRenderPassCreateInfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkRenderPassCreateInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkRenderPassCreateInfo = Struct_VkRenderPassCreateInfo;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkCommandPoolCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkCommandPoolCreateFlags,
    pub queueFamilyIndex: uint32_t,
}
impl ::std::clone::Clone for Struct_VkCommandPoolCreateInfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkCommandPoolCreateInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkCommandPoolCreateInfo = Struct_VkCommandPoolCreateInfo;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkCommandBufferAllocateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub commandPool: VkCommandPool,
    pub level: VkCommandBufferLevel,
    pub commandBufferCount: uint32_t,
}
impl ::std::clone::Clone for Struct_VkCommandBufferAllocateInfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkCommandBufferAllocateInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkCommandBufferAllocateInfo = Struct_VkCommandBufferAllocateInfo;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkCommandBufferInheritanceInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub renderPass: VkRenderPass,
    pub subpass: uint32_t,
    pub framebuffer: VkFramebuffer,
    pub occlusionQueryEnable: VkBool32,
    pub queryFlags: VkQueryControlFlags,
    pub pipelineStatistics: VkQueryPipelineStatisticFlags,
}
impl ::std::clone::Clone for Struct_VkCommandBufferInheritanceInfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkCommandBufferInheritanceInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkCommandBufferInheritanceInfo =
    Struct_VkCommandBufferInheritanceInfo;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkCommandBufferBeginInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkCommandBufferUsageFlags,
    pub pInheritanceInfo: *const VkCommandBufferInheritanceInfo,
}
impl ::std::clone::Clone for Struct_VkCommandBufferBeginInfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkCommandBufferBeginInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkCommandBufferBeginInfo = Struct_VkCommandBufferBeginInfo;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkBufferCopy {
    pub srcOffset: VkDeviceSize,
    pub dstOffset: VkDeviceSize,
    pub size: VkDeviceSize,
}
impl ::std::clone::Clone for Struct_VkBufferCopy {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkBufferCopy {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkBufferCopy = Struct_VkBufferCopy;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkImageSubresourceLayers {
    pub aspectMask: VkImageAspectFlags,
    pub mipLevel: uint32_t,
    pub baseArrayLayer: uint32_t,
    pub layerCount: uint32_t,
}
impl ::std::clone::Clone for Struct_VkImageSubresourceLayers {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkImageSubresourceLayers {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkImageSubresourceLayers = Struct_VkImageSubresourceLayers;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkImageCopy {
    pub srcSubresource: VkImageSubresourceLayers,
    pub srcOffset: VkOffset3D,
    pub dstSubresource: VkImageSubresourceLayers,
    pub dstOffset: VkOffset3D,
    pub extent: VkExtent3D,
}
impl ::std::clone::Clone for Struct_VkImageCopy {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkImageCopy {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkImageCopy = Struct_VkImageCopy;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkImageBlit {
    pub srcSubresource: VkImageSubresourceLayers,
    pub srcOffsets: [VkOffset3D; 2usize],
    pub dstSubresource: VkImageSubresourceLayers,
    pub dstOffsets: [VkOffset3D; 2usize],
}
impl ::std::clone::Clone for Struct_VkImageBlit {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkImageBlit {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkImageBlit = Struct_VkImageBlit;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkBufferImageCopy {
    pub bufferOffset: VkDeviceSize,
    pub bufferRowLength: uint32_t,
    pub bufferImageHeight: uint32_t,
    pub imageSubresource: VkImageSubresourceLayers,
    pub imageOffset: VkOffset3D,
    pub imageExtent: VkExtent3D,
}
impl ::std::clone::Clone for Struct_VkBufferImageCopy {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkBufferImageCopy {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkBufferImageCopy = Struct_VkBufferImageCopy;
#[repr(C)]
#[derive(Copy)]
pub struct Union_VkClearColorValue {
    pub _bindgen_data_: [u32; 4usize],
}
impl Union_VkClearColorValue {
    pub unsafe fn float32(&mut self)
     -> *mut [::std::os::raw::c_float; 4usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn int32(&mut self) -> *mut [int32_t; 4usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn uint32(&mut self) -> *mut [uint32_t; 4usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_VkClearColorValue {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_VkClearColorValue {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkClearColorValue = Union_VkClearColorValue;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkClearDepthStencilValue {
    pub depth: ::std::os::raw::c_float,
    pub stencil: uint32_t,
}
impl ::std::clone::Clone for Struct_VkClearDepthStencilValue {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkClearDepthStencilValue {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkClearDepthStencilValue = Struct_VkClearDepthStencilValue;
#[repr(C)]
#[derive(Copy)]
pub struct Union_VkClearValue {
    pub _bindgen_data_: [u32; 4usize],
}
impl Union_VkClearValue {
    pub unsafe fn color(&mut self) -> *mut VkClearColorValue {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn depthStencil(&mut self) -> *mut VkClearDepthStencilValue {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_VkClearValue {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_VkClearValue {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkClearValue = Union_VkClearValue;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkClearAttachment {
    pub aspectMask: VkImageAspectFlags,
    pub colorAttachment: uint32_t,
    pub clearValue: VkClearValue,
}
impl ::std::clone::Clone for Struct_VkClearAttachment {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkClearAttachment {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkClearAttachment = Struct_VkClearAttachment;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkClearRect {
    pub rect: VkRect2D,
    pub baseArrayLayer: uint32_t,
    pub layerCount: uint32_t,
}
impl ::std::clone::Clone for Struct_VkClearRect {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkClearRect {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkClearRect = Struct_VkClearRect;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkImageResolve {
    pub srcSubresource: VkImageSubresourceLayers,
    pub srcOffset: VkOffset3D,
    pub dstSubresource: VkImageSubresourceLayers,
    pub dstOffset: VkOffset3D,
    pub extent: VkExtent3D,
}
impl ::std::clone::Clone for Struct_VkImageResolve {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkImageResolve {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkImageResolve = Struct_VkImageResolve;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkMemoryBarrier {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub srcAccessMask: VkAccessFlags,
    pub dstAccessMask: VkAccessFlags,
}
impl ::std::clone::Clone for Struct_VkMemoryBarrier {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkMemoryBarrier {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkMemoryBarrier = Struct_VkMemoryBarrier;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkBufferMemoryBarrier {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub srcAccessMask: VkAccessFlags,
    pub dstAccessMask: VkAccessFlags,
    pub srcQueueFamilyIndex: uint32_t,
    pub dstQueueFamilyIndex: uint32_t,
    pub buffer: VkBuffer,
    pub offset: VkDeviceSize,
    pub size: VkDeviceSize,
}
impl ::std::clone::Clone for Struct_VkBufferMemoryBarrier {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkBufferMemoryBarrier {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkBufferMemoryBarrier = Struct_VkBufferMemoryBarrier;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkImageMemoryBarrier {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub srcAccessMask: VkAccessFlags,
    pub dstAccessMask: VkAccessFlags,
    pub oldLayout: VkImageLayout,
    pub newLayout: VkImageLayout,
    pub srcQueueFamilyIndex: uint32_t,
    pub dstQueueFamilyIndex: uint32_t,
    pub image: VkImage,
    pub subresourceRange: VkImageSubresourceRange,
}
impl ::std::clone::Clone for Struct_VkImageMemoryBarrier {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkImageMemoryBarrier {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkImageMemoryBarrier = Struct_VkImageMemoryBarrier;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkRenderPassBeginInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub renderPass: VkRenderPass,
    pub framebuffer: VkFramebuffer,
    pub renderArea: VkRect2D,
    pub clearValueCount: uint32_t,
    pub pClearValues: *const VkClearValue,
}
impl ::std::clone::Clone for Struct_VkRenderPassBeginInfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkRenderPassBeginInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkRenderPassBeginInfo = Struct_VkRenderPassBeginInfo;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkDispatchIndirectCommand {
    pub x: uint32_t,
    pub y: uint32_t,
    pub z: uint32_t,
}
impl ::std::clone::Clone for Struct_VkDispatchIndirectCommand {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkDispatchIndirectCommand {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkDispatchIndirectCommand = Struct_VkDispatchIndirectCommand;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkDrawIndexedIndirectCommand {
    pub indexCount: uint32_t,
    pub instanceCount: uint32_t,
    pub firstIndex: uint32_t,
    pub vertexOffset: int32_t,
    pub firstInstance: uint32_t,
}
impl ::std::clone::Clone for Struct_VkDrawIndexedIndirectCommand {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkDrawIndexedIndirectCommand {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkDrawIndexedIndirectCommand = Struct_VkDrawIndexedIndirectCommand;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkDrawIndirectCommand {
    pub vertexCount: uint32_t,
    pub instanceCount: uint32_t,
    pub firstVertex: uint32_t,
    pub firstInstance: uint32_t,
}
impl ::std::clone::Clone for Struct_VkDrawIndirectCommand {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkDrawIndirectCommand {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkDrawIndirectCommand = Struct_VkDrawIndirectCommand;
pub type PFN_vkCreateInstance =
    ::std::option::Option<unsafe extern "C" fn(pCreateInfo:
                                                   *const VkInstanceCreateInfo,
                                               pAllocator:
                                                   *const VkAllocationCallbacks,
                                               pInstance: *mut VkInstance)
                              -> VkResult>;
pub type PFN_vkDestroyInstance =
    ::std::option::Option<unsafe extern "C" fn(instance: VkInstance,
                                               pAllocator:
                                                   *const VkAllocationCallbacks)>;
pub type PFN_vkEnumeratePhysicalDevices =
    ::std::option::Option<unsafe extern "C" fn(instance: VkInstance,
                                               pPhysicalDeviceCount:
                                                   *mut uint32_t,
                                               pPhysicalDevices:
                                                   *mut VkPhysicalDevice)
                              -> VkResult>;
pub type PFN_vkGetPhysicalDeviceFeatures =
    ::std::option::Option<unsafe extern "C" fn(physicalDevice:
                                                   VkPhysicalDevice,
                                               pFeatures:
                                                   *mut VkPhysicalDeviceFeatures)>;
pub type PFN_vkGetPhysicalDeviceFormatProperties =
    ::std::option::Option<unsafe extern "C" fn(physicalDevice:
                                                   VkPhysicalDevice,
                                               format: VkFormat,
                                               pFormatProperties:
                                                   *mut VkFormatProperties)>;
pub type PFN_vkGetPhysicalDeviceImageFormatProperties =
    ::std::option::Option<unsafe extern "C" fn(physicalDevice:
                                                   VkPhysicalDevice,
                                               format: VkFormat,
                                               _type: VkImageType,
                                               tiling: VkImageTiling,
                                               usage: VkImageUsageFlags,
                                               flags: VkImageCreateFlags,
                                               pImageFormatProperties:
                                                   *mut VkImageFormatProperties)
                              -> VkResult>;
pub type PFN_vkGetPhysicalDeviceProperties =
    ::std::option::Option<unsafe extern "C" fn(physicalDevice:
                                                   VkPhysicalDevice,
                                               pProperties:
                                                   *mut VkPhysicalDeviceProperties)>;
pub type PFN_vkGetPhysicalDeviceQueueFamilyProperties =
    ::std::option::Option<unsafe extern "C" fn(physicalDevice:
                                                   VkPhysicalDevice,
                                               pQueueFamilyPropertyCount:
                                                   *mut uint32_t,
                                               pQueueFamilyProperties:
                                                   *mut VkQueueFamilyProperties)>;
pub type PFN_vkGetPhysicalDeviceMemoryProperties =
    ::std::option::Option<unsafe extern "C" fn(physicalDevice:
                                                   VkPhysicalDevice,
                                               pMemoryProperties:
                                                   *mut VkPhysicalDeviceMemoryProperties)>;
pub type PFN_vkGetInstanceProcAddr =
    ::std::option::Option<unsafe extern "C" fn(instance: VkInstance,
                                               pName:
                                                   *const ::std::os::raw::c_char)
                              -> PFN_vkVoidFunction>;
pub type PFN_vkGetDeviceProcAddr =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pName:
                                                   *const ::std::os::raw::c_char)
                              -> PFN_vkVoidFunction>;
pub type PFN_vkCreateDevice =
    ::std::option::Option<unsafe extern "C" fn(physicalDevice:
                                                   VkPhysicalDevice,
                                               pCreateInfo:
                                                   *const VkDeviceCreateInfo,
                                               pAllocator:
                                                   *const VkAllocationCallbacks,
                                               pDevice: *mut VkDevice)
                              -> VkResult>;
pub type PFN_vkDestroyDevice =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pAllocator:
                                                   *const VkAllocationCallbacks)>;
pub type PFN_vkEnumerateInstanceExtensionProperties =
    ::std::option::Option<unsafe extern "C" fn(pLayerName:
                                                   *const ::std::os::raw::c_char,
                                               pPropertyCount: *mut uint32_t,
                                               pProperties:
                                                   *mut VkExtensionProperties)
                              -> VkResult>;
pub type PFN_vkEnumerateDeviceExtensionProperties =
    ::std::option::Option<unsafe extern "C" fn(physicalDevice:
                                                   VkPhysicalDevice,
                                               pLayerName:
                                                   *const ::std::os::raw::c_char,
                                               pPropertyCount: *mut uint32_t,
                                               pProperties:
                                                   *mut VkExtensionProperties)
                              -> VkResult>;
pub type PFN_vkEnumerateInstanceLayerProperties =
    ::std::option::Option<unsafe extern "C" fn(pPropertyCount: *mut uint32_t,
                                               pProperties:
                                                   *mut VkLayerProperties)
                              -> VkResult>;
pub type PFN_vkEnumerateDeviceLayerProperties =
    ::std::option::Option<unsafe extern "C" fn(physicalDevice:
                                                   VkPhysicalDevice,
                                               pPropertyCount: *mut uint32_t,
                                               pProperties:
                                                   *mut VkLayerProperties)
                              -> VkResult>;
pub type PFN_vkGetDeviceQueue =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               queueFamilyIndex: uint32_t,
                                               queueIndex: uint32_t,
                                               pQueue: *mut VkQueue)>;
pub type PFN_vkQueueSubmit =
    ::std::option::Option<unsafe extern "C" fn(queue: VkQueue,
                                               submitCount: uint32_t,
                                               pSubmits: *const VkSubmitInfo,
                                               fence: VkFence) -> VkResult>;
pub type PFN_vkQueueWaitIdle =
    ::std::option::Option<extern "C" fn(queue: VkQueue) -> VkResult>;
pub type PFN_vkDeviceWaitIdle =
    ::std::option::Option<extern "C" fn(device: VkDevice) -> VkResult>;
pub type PFN_vkAllocateMemory =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pAllocateInfo:
                                                   *const VkMemoryAllocateInfo,
                                               pAllocator:
                                                   *const VkAllocationCallbacks,
                                               pMemory: *mut VkDeviceMemory)
                              -> VkResult>;
pub type PFN_vkFreeMemory =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               memory: VkDeviceMemory,
                                               pAllocator:
                                                   *const VkAllocationCallbacks)>;
pub type PFN_vkMapMemory =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               memory: VkDeviceMemory,
                                               offset: VkDeviceSize,
                                               size: VkDeviceSize,
                                               flags: VkMemoryMapFlags,
                                               ppData:
                                                   *mut *mut ::std::os::raw::c_void)
                              -> VkResult>;
pub type PFN_vkUnmapMemory =
    ::std::option::Option<extern "C" fn(device: VkDevice,
                                        memory: VkDeviceMemory)>;
pub type PFN_vkFlushMappedMemoryRanges =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               memoryRangeCount: uint32_t,
                                               pMemoryRanges:
                                                   *const VkMappedMemoryRange)
                              -> VkResult>;
pub type PFN_vkInvalidateMappedMemoryRanges =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               memoryRangeCount: uint32_t,
                                               pMemoryRanges:
                                                   *const VkMappedMemoryRange)
                              -> VkResult>;
pub type PFN_vkGetDeviceMemoryCommitment =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               memory: VkDeviceMemory,
                                               pCommittedMemoryInBytes:
                                                   *mut VkDeviceSize)>;
pub type PFN_vkBindBufferMemory =
    ::std::option::Option<extern "C" fn(device: VkDevice, buffer: VkBuffer,
                                        memory: VkDeviceMemory,
                                        memoryOffset: VkDeviceSize)
                              -> VkResult>;
pub type PFN_vkBindImageMemory =
    ::std::option::Option<extern "C" fn(device: VkDevice, image: VkImage,
                                        memory: VkDeviceMemory,
                                        memoryOffset: VkDeviceSize)
                              -> VkResult>;
pub type PFN_vkGetBufferMemoryRequirements =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               buffer: VkBuffer,
                                               pMemoryRequirements:
                                                   *mut VkMemoryRequirements)>;
pub type PFN_vkGetImageMemoryRequirements =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               image: VkImage,
                                               pMemoryRequirements:
                                                   *mut VkMemoryRequirements)>;
pub type PFN_vkGetImageSparseMemoryRequirements =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               image: VkImage,
                                               pSparseMemoryRequirementCount:
                                                   *mut uint32_t,
                                               pSparseMemoryRequirements:
                                                   *mut VkSparseImageMemoryRequirements)>;
pub type PFN_vkGetPhysicalDeviceSparseImageFormatProperties =
    ::std::option::Option<unsafe extern "C" fn(physicalDevice:
                                                   VkPhysicalDevice,
                                               format: VkFormat,
                                               _type: VkImageType,
                                               samples: VkSampleCountFlagBits,
                                               usage: VkImageUsageFlags,
                                               tiling: VkImageTiling,
                                               pPropertyCount: *mut uint32_t,
                                               pProperties:
                                                   *mut VkSparseImageFormatProperties)>;
pub type PFN_vkQueueBindSparse =
    ::std::option::Option<unsafe extern "C" fn(queue: VkQueue,
                                               bindInfoCount: uint32_t,
                                               pBindInfo:
                                                   *const VkBindSparseInfo,
                                               fence: VkFence) -> VkResult>;
pub type PFN_vkCreateFence =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pCreateInfo:
                                                   *const VkFenceCreateInfo,
                                               pAllocator:
                                                   *const VkAllocationCallbacks,
                                               pFence: *mut VkFence)
                              -> VkResult>;
pub type PFN_vkDestroyFence =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               fence: VkFence,
                                               pAllocator:
                                                   *const VkAllocationCallbacks)>;
pub type PFN_vkResetFences =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               fenceCount: uint32_t,
                                               pFences: *const VkFence)
                              -> VkResult>;
pub type PFN_vkGetFenceStatus =
    ::std::option::Option<extern "C" fn(device: VkDevice, fence: VkFence)
                              -> VkResult>;
pub type PFN_vkWaitForFences =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               fenceCount: uint32_t,
                                               pFences: *const VkFence,
                                               waitAll: VkBool32,
                                               timeout: uint64_t)
                              -> VkResult>;
pub type PFN_vkCreateSemaphore =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pCreateInfo:
                                                   *const VkSemaphoreCreateInfo,
                                               pAllocator:
                                                   *const VkAllocationCallbacks,
                                               pSemaphore: *mut VkSemaphore)
                              -> VkResult>;
pub type PFN_vkDestroySemaphore =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               semaphore: VkSemaphore,
                                               pAllocator:
                                                   *const VkAllocationCallbacks)>;
pub type PFN_vkCreateEvent =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pCreateInfo:
                                                   *const VkEventCreateInfo,
                                               pAllocator:
                                                   *const VkAllocationCallbacks,
                                               pEvent: *mut VkEvent)
                              -> VkResult>;
pub type PFN_vkDestroyEvent =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               event: VkEvent,
                                               pAllocator:
                                                   *const VkAllocationCallbacks)>;
pub type PFN_vkGetEventStatus =
    ::std::option::Option<extern "C" fn(device: VkDevice, event: VkEvent)
                              -> VkResult>;
pub type PFN_vkSetEvent =
    ::std::option::Option<extern "C" fn(device: VkDevice, event: VkEvent)
                              -> VkResult>;
pub type PFN_vkResetEvent =
    ::std::option::Option<extern "C" fn(device: VkDevice, event: VkEvent)
                              -> VkResult>;
pub type PFN_vkCreateQueryPool =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pCreateInfo:
                                                   *const VkQueryPoolCreateInfo,
                                               pAllocator:
                                                   *const VkAllocationCallbacks,
                                               pQueryPool: *mut VkQueryPool)
                              -> VkResult>;
pub type PFN_vkDestroyQueryPool =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               queryPool: VkQueryPool,
                                               pAllocator:
                                                   *const VkAllocationCallbacks)>;
pub type PFN_vkGetQueryPoolResults =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               queryPool: VkQueryPool,
                                               firstQuery: uint32_t,
                                               queryCount: uint32_t,
                                               dataSize: size_t,
                                               pData:
                                                   *mut ::std::os::raw::c_void,
                                               stride: VkDeviceSize,
                                               flags: VkQueryResultFlags)
                              -> VkResult>;
pub type PFN_vkCreateBuffer =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pCreateInfo:
                                                   *const VkBufferCreateInfo,
                                               pAllocator:
                                                   *const VkAllocationCallbacks,
                                               pBuffer: *mut VkBuffer)
                              -> VkResult>;
pub type PFN_vkDestroyBuffer =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               buffer: VkBuffer,
                                               pAllocator:
                                                   *const VkAllocationCallbacks)>;
pub type PFN_vkCreateBufferView =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pCreateInfo:
                                                   *const VkBufferViewCreateInfo,
                                               pAllocator:
                                                   *const VkAllocationCallbacks,
                                               pView: *mut VkBufferView)
                              -> VkResult>;
pub type PFN_vkDestroyBufferView =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               bufferView: VkBufferView,
                                               pAllocator:
                                                   *const VkAllocationCallbacks)>;
pub type PFN_vkCreateImage =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pCreateInfo:
                                                   *const VkImageCreateInfo,
                                               pAllocator:
                                                   *const VkAllocationCallbacks,
                                               pImage: *mut VkImage)
                              -> VkResult>;
pub type PFN_vkDestroyImage =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               image: VkImage,
                                               pAllocator:
                                                   *const VkAllocationCallbacks)>;
pub type PFN_vkGetImageSubresourceLayout =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               image: VkImage,
                                               pSubresource:
                                                   *const VkImageSubresource,
                                               pLayout:
                                                   *mut VkSubresourceLayout)>;
pub type PFN_vkCreateImageView =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pCreateInfo:
                                                   *const VkImageViewCreateInfo,
                                               pAllocator:
                                                   *const VkAllocationCallbacks,
                                               pView: *mut VkImageView)
                              -> VkResult>;
pub type PFN_vkDestroyImageView =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               imageView: VkImageView,
                                               pAllocator:
                                                   *const VkAllocationCallbacks)>;
pub type PFN_vkCreateShaderModule =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pCreateInfo:
                                                   *const VkShaderModuleCreateInfo,
                                               pAllocator:
                                                   *const VkAllocationCallbacks,
                                               pShaderModule:
                                                   *mut VkShaderModule)
                              -> VkResult>;
pub type PFN_vkDestroyShaderModule =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               shaderModule: VkShaderModule,
                                               pAllocator:
                                                   *const VkAllocationCallbacks)>;
pub type PFN_vkCreatePipelineCache =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pCreateInfo:
                                                   *const VkPipelineCacheCreateInfo,
                                               pAllocator:
                                                   *const VkAllocationCallbacks,
                                               pPipelineCache:
                                                   *mut VkPipelineCache)
                              -> VkResult>;
pub type PFN_vkDestroyPipelineCache =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pipelineCache: VkPipelineCache,
                                               pAllocator:
                                                   *const VkAllocationCallbacks)>;
pub type PFN_vkGetPipelineCacheData =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pipelineCache: VkPipelineCache,
                                               pDataSize: *mut size_t,
                                               pData:
                                                   *mut ::std::os::raw::c_void)
                              -> VkResult>;
pub type PFN_vkMergePipelineCaches =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               dstCache: VkPipelineCache,
                                               srcCacheCount: uint32_t,
                                               pSrcCaches:
                                                   *const VkPipelineCache)
                              -> VkResult>;
pub type PFN_vkCreateGraphicsPipelines =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pipelineCache: VkPipelineCache,
                                               createInfoCount: uint32_t,
                                               pCreateInfos:
                                                   *const VkGraphicsPipelineCreateInfo,
                                               pAllocator:
                                                   *const VkAllocationCallbacks,
                                               pPipelines: *mut VkPipeline)
                              -> VkResult>;
pub type PFN_vkCreateComputePipelines =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pipelineCache: VkPipelineCache,
                                               createInfoCount: uint32_t,
                                               pCreateInfos:
                                                   *const VkComputePipelineCreateInfo,
                                               pAllocator:
                                                   *const VkAllocationCallbacks,
                                               pPipelines: *mut VkPipeline)
                              -> VkResult>;
pub type PFN_vkDestroyPipeline =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pipeline: VkPipeline,
                                               pAllocator:
                                                   *const VkAllocationCallbacks)>;
pub type PFN_vkCreatePipelineLayout =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pCreateInfo:
                                                   *const VkPipelineLayoutCreateInfo,
                                               pAllocator:
                                                   *const VkAllocationCallbacks,
                                               pPipelineLayout:
                                                   *mut VkPipelineLayout)
                              -> VkResult>;
pub type PFN_vkDestroyPipelineLayout =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pipelineLayout:
                                                   VkPipelineLayout,
                                               pAllocator:
                                                   *const VkAllocationCallbacks)>;
pub type PFN_vkCreateSampler =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pCreateInfo:
                                                   *const VkSamplerCreateInfo,
                                               pAllocator:
                                                   *const VkAllocationCallbacks,
                                               pSampler: *mut VkSampler)
                              -> VkResult>;
pub type PFN_vkDestroySampler =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               sampler: VkSampler,
                                               pAllocator:
                                                   *const VkAllocationCallbacks)>;
pub type PFN_vkCreateDescriptorSetLayout =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pCreateInfo:
                                                   *const VkDescriptorSetLayoutCreateInfo,
                                               pAllocator:
                                                   *const VkAllocationCallbacks,
                                               pSetLayout:
                                                   *mut VkDescriptorSetLayout)
                              -> VkResult>;
pub type PFN_vkDestroyDescriptorSetLayout =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               descriptorSetLayout:
                                                   VkDescriptorSetLayout,
                                               pAllocator:
                                                   *const VkAllocationCallbacks)>;
pub type PFN_vkCreateDescriptorPool =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pCreateInfo:
                                                   *const VkDescriptorPoolCreateInfo,
                                               pAllocator:
                                                   *const VkAllocationCallbacks,
                                               pDescriptorPool:
                                                   *mut VkDescriptorPool)
                              -> VkResult>;
pub type PFN_vkDestroyDescriptorPool =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               descriptorPool:
                                                   VkDescriptorPool,
                                               pAllocator:
                                                   *const VkAllocationCallbacks)>;
pub type PFN_vkResetDescriptorPool =
    ::std::option::Option<extern "C" fn(device: VkDevice,
                                        descriptorPool: VkDescriptorPool,
                                        flags: VkDescriptorPoolResetFlags)
                              -> VkResult>;
pub type PFN_vkAllocateDescriptorSets =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pAllocateInfo:
                                                   *const VkDescriptorSetAllocateInfo,
                                               pDescriptorSets:
                                                   *mut VkDescriptorSet)
                              -> VkResult>;
pub type PFN_vkFreeDescriptorSets =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               descriptorPool:
                                                   VkDescriptorPool,
                                               descriptorSetCount: uint32_t,
                                               pDescriptorSets:
                                                   *const VkDescriptorSet)
                              -> VkResult>;
pub type PFN_vkUpdateDescriptorSets =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               descriptorWriteCount: uint32_t,
                                               pDescriptorWrites:
                                                   *const VkWriteDescriptorSet,
                                               descriptorCopyCount: uint32_t,
                                               pDescriptorCopies:
                                                   *const VkCopyDescriptorSet)>;
pub type PFN_vkCreateFramebuffer =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pCreateInfo:
                                                   *const VkFramebufferCreateInfo,
                                               pAllocator:
                                                   *const VkAllocationCallbacks,
                                               pFramebuffer:
                                                   *mut VkFramebuffer)
                              -> VkResult>;
pub type PFN_vkDestroyFramebuffer =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               framebuffer: VkFramebuffer,
                                               pAllocator:
                                                   *const VkAllocationCallbacks)>;
pub type PFN_vkCreateRenderPass =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pCreateInfo:
                                                   *const VkRenderPassCreateInfo,
                                               pAllocator:
                                                   *const VkAllocationCallbacks,
                                               pRenderPass: *mut VkRenderPass)
                              -> VkResult>;
pub type PFN_vkDestroyRenderPass =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               renderPass: VkRenderPass,
                                               pAllocator:
                                                   *const VkAllocationCallbacks)>;
pub type PFN_vkGetRenderAreaGranularity =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               renderPass: VkRenderPass,
                                               pGranularity:
                                                   *mut VkExtent2D)>;
pub type PFN_vkCreateCommandPool =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pCreateInfo:
                                                   *const VkCommandPoolCreateInfo,
                                               pAllocator:
                                                   *const VkAllocationCallbacks,
                                               pCommandPool:
                                                   *mut VkCommandPool)
                              -> VkResult>;
pub type PFN_vkDestroyCommandPool =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               commandPool: VkCommandPool,
                                               pAllocator:
                                                   *const VkAllocationCallbacks)>;
pub type PFN_vkResetCommandPool =
    ::std::option::Option<extern "C" fn(device: VkDevice,
                                        commandPool: VkCommandPool,
                                        flags: VkCommandPoolResetFlags)
                              -> VkResult>;
pub type PFN_vkAllocateCommandBuffers =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pAllocateInfo:
                                                   *const VkCommandBufferAllocateInfo,
                                               pCommandBuffers:
                                                   *mut VkCommandBuffer)
                              -> VkResult>;
pub type PFN_vkFreeCommandBuffers =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               commandPool: VkCommandPool,
                                               commandBufferCount: uint32_t,
                                               pCommandBuffers:
                                                   *const VkCommandBuffer)>;
pub type PFN_vkBeginCommandBuffer =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               pBeginInfo:
                                                   *const VkCommandBufferBeginInfo)
                              -> VkResult>;
pub type PFN_vkEndCommandBuffer =
    ::std::option::Option<extern "C" fn(commandBuffer: VkCommandBuffer)
                              -> VkResult>;
pub type PFN_vkResetCommandBuffer =
    ::std::option::Option<extern "C" fn(commandBuffer: VkCommandBuffer,
                                        flags: VkCommandBufferResetFlags)
                              -> VkResult>;
pub type PFN_vkCmdBindPipeline =
    ::std::option::Option<extern "C" fn(commandBuffer: VkCommandBuffer,
                                        pipelineBindPoint:
                                            VkPipelineBindPoint,
                                        pipeline: VkPipeline)>;
pub type PFN_vkCmdSetViewport =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               firstViewport: uint32_t,
                                               viewportCount: uint32_t,
                                               pViewports:
                                                   *const VkViewport)>;
pub type PFN_vkCmdSetScissor =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               firstScissor: uint32_t,
                                               scissorCount: uint32_t,
                                               pScissors: *const VkRect2D)>;
pub type PFN_vkCmdSetLineWidth =
    ::std::option::Option<extern "C" fn(commandBuffer: VkCommandBuffer,
                                        lineWidth: ::std::os::raw::c_float)>;
pub type PFN_vkCmdSetDepthBias =
    ::std::option::Option<extern "C" fn(commandBuffer: VkCommandBuffer,
                                        depthBiasConstantFactor:
                                            ::std::os::raw::c_float,
                                        depthBiasClamp:
                                            ::std::os::raw::c_float,
                                        depthBiasSlopeFactor:
                                            ::std::os::raw::c_float)>;
pub type PFN_vkCmdSetBlendConstants =
    ::std::option::Option<extern "C" fn(commandBuffer: VkCommandBuffer,
                                        blendConstants:
                                            *mut ::std::os::raw::c_float)>;
pub type PFN_vkCmdSetDepthBounds =
    ::std::option::Option<extern "C" fn(commandBuffer: VkCommandBuffer,
                                        minDepthBounds:
                                            ::std::os::raw::c_float,
                                        maxDepthBounds:
                                            ::std::os::raw::c_float)>;
pub type PFN_vkCmdSetStencilCompareMask =
    ::std::option::Option<extern "C" fn(commandBuffer: VkCommandBuffer,
                                        faceMask: VkStencilFaceFlags,
                                        compareMask: uint32_t)>;
pub type PFN_vkCmdSetStencilWriteMask =
    ::std::option::Option<extern "C" fn(commandBuffer: VkCommandBuffer,
                                        faceMask: VkStencilFaceFlags,
                                        writeMask: uint32_t)>;
pub type PFN_vkCmdSetStencilReference =
    ::std::option::Option<extern "C" fn(commandBuffer: VkCommandBuffer,
                                        faceMask: VkStencilFaceFlags,
                                        reference: uint32_t)>;
pub type PFN_vkCmdBindDescriptorSets =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               pipelineBindPoint:
                                                   VkPipelineBindPoint,
                                               layout: VkPipelineLayout,
                                               firstSet: uint32_t,
                                               descriptorSetCount: uint32_t,
                                               pDescriptorSets:
                                                   *const VkDescriptorSet,
                                               dynamicOffsetCount: uint32_t,
                                               pDynamicOffsets:
                                                   *const uint32_t)>;
pub type PFN_vkCmdBindIndexBuffer =
    ::std::option::Option<extern "C" fn(commandBuffer: VkCommandBuffer,
                                        buffer: VkBuffer,
                                        offset: VkDeviceSize,
                                        indexType: VkIndexType)>;
pub type PFN_vkCmdBindVertexBuffers =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               firstBinding: uint32_t,
                                               bindingCount: uint32_t,
                                               pBuffers: *const VkBuffer,
                                               pOffsets:
                                                   *const VkDeviceSize)>;
pub type PFN_vkCmdDraw =
    ::std::option::Option<extern "C" fn(commandBuffer: VkCommandBuffer,
                                        vertexCount: uint32_t,
                                        instanceCount: uint32_t,
                                        firstVertex: uint32_t,
                                        firstInstance: uint32_t)>;
pub type PFN_vkCmdDrawIndexed =
    ::std::option::Option<extern "C" fn(commandBuffer: VkCommandBuffer,
                                        indexCount: uint32_t,
                                        instanceCount: uint32_t,
                                        firstIndex: uint32_t,
                                        vertexOffset: int32_t,
                                        firstInstance: uint32_t)>;
pub type PFN_vkCmdDrawIndirect =
    ::std::option::Option<extern "C" fn(commandBuffer: VkCommandBuffer,
                                        buffer: VkBuffer,
                                        offset: VkDeviceSize,
                                        drawCount: uint32_t,
                                        stride: uint32_t)>;
pub type PFN_vkCmdDrawIndexedIndirect =
    ::std::option::Option<extern "C" fn(commandBuffer: VkCommandBuffer,
                                        buffer: VkBuffer,
                                        offset: VkDeviceSize,
                                        drawCount: uint32_t,
                                        stride: uint32_t)>;
pub type PFN_vkCmdDispatch =
    ::std::option::Option<extern "C" fn(commandBuffer: VkCommandBuffer,
                                        x: uint32_t, y: uint32_t,
                                        z: uint32_t)>;
pub type PFN_vkCmdDispatchIndirect =
    ::std::option::Option<extern "C" fn(commandBuffer: VkCommandBuffer,
                                        buffer: VkBuffer,
                                        offset: VkDeviceSize)>;
pub type PFN_vkCmdCopyBuffer =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               srcBuffer: VkBuffer,
                                               dstBuffer: VkBuffer,
                                               regionCount: uint32_t,
                                               pRegions:
                                                   *const VkBufferCopy)>;
pub type PFN_vkCmdCopyImage =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               srcImage: VkImage,
                                               srcImageLayout: VkImageLayout,
                                               dstImage: VkImage,
                                               dstImageLayout: VkImageLayout,
                                               regionCount: uint32_t,
                                               pRegions: *const VkImageCopy)>;
pub type PFN_vkCmdBlitImage =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               srcImage: VkImage,
                                               srcImageLayout: VkImageLayout,
                                               dstImage: VkImage,
                                               dstImageLayout: VkImageLayout,
                                               regionCount: uint32_t,
                                               pRegions: *const VkImageBlit,
                                               filter: VkFilter)>;
pub type PFN_vkCmdCopyBufferToImage =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               srcBuffer: VkBuffer,
                                               dstImage: VkImage,
                                               dstImageLayout: VkImageLayout,
                                               regionCount: uint32_t,
                                               pRegions:
                                                   *const VkBufferImageCopy)>;
pub type PFN_vkCmdCopyImageToBuffer =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               srcImage: VkImage,
                                               srcImageLayout: VkImageLayout,
                                               dstBuffer: VkBuffer,
                                               regionCount: uint32_t,
                                               pRegions:
                                                   *const VkBufferImageCopy)>;
pub type PFN_vkCmdUpdateBuffer =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               dstBuffer: VkBuffer,
                                               dstOffset: VkDeviceSize,
                                               dataSize: VkDeviceSize,
                                               pData: *const uint32_t)>;
pub type PFN_vkCmdFillBuffer =
    ::std::option::Option<extern "C" fn(commandBuffer: VkCommandBuffer,
                                        dstBuffer: VkBuffer,
                                        dstOffset: VkDeviceSize,
                                        size: VkDeviceSize, data: uint32_t)>;
pub type PFN_vkCmdClearColorImage =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               image: VkImage,
                                               imageLayout: VkImageLayout,
                                               pColor:
                                                   *const VkClearColorValue,
                                               rangeCount: uint32_t,
                                               pRanges:
                                                   *const VkImageSubresourceRange)>;
pub type PFN_vkCmdClearDepthStencilImage =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               image: VkImage,
                                               imageLayout: VkImageLayout,
                                               pDepthStencil:
                                                   *const VkClearDepthStencilValue,
                                               rangeCount: uint32_t,
                                               pRanges:
                                                   *const VkImageSubresourceRange)>;
pub type PFN_vkCmdClearAttachments =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               attachmentCount: uint32_t,
                                               pAttachments:
                                                   *const VkClearAttachment,
                                               rectCount: uint32_t,
                                               pRects: *const VkClearRect)>;
pub type PFN_vkCmdResolveImage =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               srcImage: VkImage,
                                               srcImageLayout: VkImageLayout,
                                               dstImage: VkImage,
                                               dstImageLayout: VkImageLayout,
                                               regionCount: uint32_t,
                                               pRegions:
                                                   *const VkImageResolve)>;
pub type PFN_vkCmdSetEvent =
    ::std::option::Option<extern "C" fn(commandBuffer: VkCommandBuffer,
                                        event: VkEvent,
                                        stageMask: VkPipelineStageFlags)>;
pub type PFN_vkCmdResetEvent =
    ::std::option::Option<extern "C" fn(commandBuffer: VkCommandBuffer,
                                        event: VkEvent,
                                        stageMask: VkPipelineStageFlags)>;
pub type PFN_vkCmdWaitEvents =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               eventCount: uint32_t,
                                               pEvents: *const VkEvent,
                                               srcStageMask:
                                                   VkPipelineStageFlags,
                                               dstStageMask:
                                                   VkPipelineStageFlags,
                                               memoryBarrierCount: uint32_t,
                                               pMemoryBarriers:
                                                   *const VkMemoryBarrier,
                                               bufferMemoryBarrierCount:
                                                   uint32_t,
                                               pBufferMemoryBarriers:
                                                   *const VkBufferMemoryBarrier,
                                               imageMemoryBarrierCount:
                                                   uint32_t,
                                               pImageMemoryBarriers:
                                                   *const VkImageMemoryBarrier)>;
pub type PFN_vkCmdPipelineBarrier =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               srcStageMask:
                                                   VkPipelineStageFlags,
                                               dstStageMask:
                                                   VkPipelineStageFlags,
                                               dependencyFlags:
                                                   VkDependencyFlags,
                                               memoryBarrierCount: uint32_t,
                                               pMemoryBarriers:
                                                   *const VkMemoryBarrier,
                                               bufferMemoryBarrierCount:
                                                   uint32_t,
                                               pBufferMemoryBarriers:
                                                   *const VkBufferMemoryBarrier,
                                               imageMemoryBarrierCount:
                                                   uint32_t,
                                               pImageMemoryBarriers:
                                                   *const VkImageMemoryBarrier)>;
pub type PFN_vkCmdBeginQuery =
    ::std::option::Option<extern "C" fn(commandBuffer: VkCommandBuffer,
                                        queryPool: VkQueryPool,
                                        query: uint32_t,
                                        flags: VkQueryControlFlags)>;
pub type PFN_vkCmdEndQuery =
    ::std::option::Option<extern "C" fn(commandBuffer: VkCommandBuffer,
                                        queryPool: VkQueryPool,
                                        query: uint32_t)>;
pub type PFN_vkCmdResetQueryPool =
    ::std::option::Option<extern "C" fn(commandBuffer: VkCommandBuffer,
                                        queryPool: VkQueryPool,
                                        firstQuery: uint32_t,
                                        queryCount: uint32_t)>;
pub type PFN_vkCmdWriteTimestamp =
    ::std::option::Option<extern "C" fn(commandBuffer: VkCommandBuffer,
                                        pipelineStage:
                                            VkPipelineStageFlagBits,
                                        queryPool: VkQueryPool,
                                        query: uint32_t)>;
pub type PFN_vkCmdCopyQueryPoolResults =
    ::std::option::Option<extern "C" fn(commandBuffer: VkCommandBuffer,
                                        queryPool: VkQueryPool,
                                        firstQuery: uint32_t,
                                        queryCount: uint32_t,
                                        dstBuffer: VkBuffer,
                                        dstOffset: VkDeviceSize,
                                        stride: VkDeviceSize,
                                        flags: VkQueryResultFlags)>;
pub type PFN_vkCmdPushConstants =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               layout: VkPipelineLayout,
                                               stageFlags: VkShaderStageFlags,
                                               offset: uint32_t,
                                               size: uint32_t,
                                               pValues:
                                                   *const ::std::os::raw::c_void)>;
pub type PFN_vkCmdBeginRenderPass =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               pRenderPassBegin:
                                                   *const VkRenderPassBeginInfo,
                                               contents: VkSubpassContents)>;
pub type PFN_vkCmdNextSubpass =
    ::std::option::Option<extern "C" fn(commandBuffer: VkCommandBuffer,
                                        contents: VkSubpassContents)>;
pub type PFN_vkCmdEndRenderPass =
    ::std::option::Option<extern "C" fn(commandBuffer: VkCommandBuffer)>;
pub type PFN_vkCmdExecuteCommands =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               commandBufferCount: uint32_t,
                                               pCommandBuffers:
                                                   *const VkCommandBuffer)>;
pub enum Struct_VkSurfaceKHR_T { }
pub type VkSurfaceKHR = *mut Struct_VkSurfaceKHR_T;
pub const VK_COLORSPACE_BEGIN_RANGE: Enum_VkColorSpaceKHR =
    Enum_VkColorSpaceKHR::VK_COLORSPACE_SRGB_NONLINEAR_KHR;
pub const VK_COLORSPACE_END_RANGE: Enum_VkColorSpaceKHR =
    Enum_VkColorSpaceKHR::VK_COLORSPACE_SRGB_NONLINEAR_KHR;
#[derive(Clone, Eq, PartialEq, Debug, Copy)]
#[repr(u32)]
pub enum Enum_VkColorSpaceKHR {
    VK_COLORSPACE_SRGB_NONLINEAR_KHR = 0,
    VK_COLORSPACE_RANGE_SIZE = 1,
    VK_COLORSPACE_MAX_ENUM = 2147483647,
}
pub type VkColorSpaceKHR = Enum_VkColorSpaceKHR;
pub const VK_PRESENT_MODE_BEGIN_RANGE: Enum_VkPresentModeKHR =
    Enum_VkPresentModeKHR::VK_PRESENT_MODE_IMMEDIATE_KHR;
pub const VK_PRESENT_MODE_END_RANGE: Enum_VkPresentModeKHR =
    Enum_VkPresentModeKHR::VK_PRESENT_MODE_FIFO_RELAXED_KHR;
#[derive(Clone, Eq, PartialEq, Debug, Copy)]
#[repr(u32)]
pub enum Enum_VkPresentModeKHR {
    VK_PRESENT_MODE_IMMEDIATE_KHR = 0,
    VK_PRESENT_MODE_MAILBOX_KHR = 1,
    VK_PRESENT_MODE_FIFO_KHR = 2,
    VK_PRESENT_MODE_FIFO_RELAXED_KHR = 3,
    VK_PRESENT_MODE_RANGE_SIZE = 4,
    VK_PRESENT_MODE_MAX_ENUM = 2147483647,
}
pub type VkPresentModeKHR = Enum_VkPresentModeKHR;
#[derive(Clone, Eq, PartialEq, Debug, Copy)]
#[repr(u32)]
pub enum Enum_VkSurfaceTransformFlagBitsKHR {
    VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR = 1,
    VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR = 2,
    VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR = 4,
    VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR = 8,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR = 16,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR = 32,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR = 64,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR = 128,
    VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR = 256,
}
pub type VkSurfaceTransformFlagBitsKHR = Enum_VkSurfaceTransformFlagBitsKHR;
pub type VkSurfaceTransformFlagsKHR = VkFlags;
#[derive(Clone, Eq, PartialEq, Debug, Copy)]
#[repr(u32)]
pub enum Enum_VkCompositeAlphaFlagBitsKHR {
    VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR = 1,
    VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR = 2,
    VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR = 4,
    VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR = 8,
}
pub type VkCompositeAlphaFlagBitsKHR = Enum_VkCompositeAlphaFlagBitsKHR;
pub type VkCompositeAlphaFlagsKHR = VkFlags;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkSurfaceCapabilitiesKHR {
    pub minImageCount: uint32_t,
    pub maxImageCount: uint32_t,
    pub currentExtent: VkExtent2D,
    pub minImageExtent: VkExtent2D,
    pub maxImageExtent: VkExtent2D,
    pub maxImageArrayLayers: uint32_t,
    pub supportedTransforms: VkSurfaceTransformFlagsKHR,
    pub currentTransform: VkSurfaceTransformFlagBitsKHR,
    pub supportedCompositeAlpha: VkCompositeAlphaFlagsKHR,
    pub supportedUsageFlags: VkImageUsageFlags,
}
impl ::std::clone::Clone for Struct_VkSurfaceCapabilitiesKHR {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkSurfaceCapabilitiesKHR {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkSurfaceCapabilitiesKHR = Struct_VkSurfaceCapabilitiesKHR;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkSurfaceFormatKHR {
    pub format: VkFormat,
    pub colorSpace: VkColorSpaceKHR,
}
impl ::std::clone::Clone for Struct_VkSurfaceFormatKHR {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkSurfaceFormatKHR {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkSurfaceFormatKHR = Struct_VkSurfaceFormatKHR;
pub type PFN_vkDestroySurfaceKHR =
    ::std::option::Option<unsafe extern "C" fn(instance: VkInstance,
                                               surface: VkSurfaceKHR,
                                               pAllocator:
                                                   *const VkAllocationCallbacks)>;
pub type PFN_vkGetPhysicalDeviceSurfaceSupportKHR =
    ::std::option::Option<unsafe extern "C" fn(physicalDevice:
                                                   VkPhysicalDevice,
                                               queueFamilyIndex: uint32_t,
                                               surface: VkSurfaceKHR,
                                               pSupported: *mut VkBool32)
                              -> VkResult>;
pub type PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR =
    ::std::option::Option<unsafe extern "C" fn(physicalDevice:
                                                   VkPhysicalDevice,
                                               surface: VkSurfaceKHR,
                                               pSurfaceCapabilities:
                                                   *mut VkSurfaceCapabilitiesKHR)
                              -> VkResult>;
pub type PFN_vkGetPhysicalDeviceSurfaceFormatsKHR =
    ::std::option::Option<unsafe extern "C" fn(physicalDevice:
                                                   VkPhysicalDevice,
                                               surface: VkSurfaceKHR,
                                               pSurfaceFormatCount:
                                                   *mut uint32_t,
                                               pSurfaceFormats:
                                                   *mut VkSurfaceFormatKHR)
                              -> VkResult>;
pub type PFN_vkGetPhysicalDeviceSurfacePresentModesKHR =
    ::std::option::Option<unsafe extern "C" fn(physicalDevice:
                                                   VkPhysicalDevice,
                                               surface: VkSurfaceKHR,
                                               pPresentModeCount:
                                                   *mut uint32_t,
                                               pPresentModes:
                                                   *mut VkPresentModeKHR)
                              -> VkResult>;
pub enum Struct_VkSwapchainKHR_T { }
pub type VkSwapchainKHR = *mut Struct_VkSwapchainKHR_T;
pub type VkSwapchainCreateFlagsKHR = VkFlags;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkSwapchainCreateInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkSwapchainCreateFlagsKHR,
    pub surface: VkSurfaceKHR,
    pub minImageCount: uint32_t,
    pub imageFormat: VkFormat,
    pub imageColorSpace: VkColorSpaceKHR,
    pub imageExtent: VkExtent2D,
    pub imageArrayLayers: uint32_t,
    pub imageUsage: VkImageUsageFlags,
    pub imageSharingMode: VkSharingMode,
    pub queueFamilyIndexCount: uint32_t,
    pub pQueueFamilyIndices: *const uint32_t,
    pub preTransform: VkSurfaceTransformFlagBitsKHR,
    pub compositeAlpha: VkCompositeAlphaFlagBitsKHR,
    pub presentMode: VkPresentModeKHR,
    pub clipped: VkBool32,
    pub oldSwapchain: VkSwapchainKHR,
}
impl ::std::clone::Clone for Struct_VkSwapchainCreateInfoKHR {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkSwapchainCreateInfoKHR {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkSwapchainCreateInfoKHR = Struct_VkSwapchainCreateInfoKHR;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkPresentInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub waitSemaphoreCount: uint32_t,
    pub pWaitSemaphores: *const VkSemaphore,
    pub swapchainCount: uint32_t,
    pub pSwapchains: *const VkSwapchainKHR,
    pub pImageIndices: *const uint32_t,
    pub pResults: *mut VkResult,
}
impl ::std::clone::Clone for Struct_VkPresentInfoKHR {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkPresentInfoKHR {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkPresentInfoKHR = Struct_VkPresentInfoKHR;
pub type PFN_vkCreateSwapchainKHR =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pCreateInfo:
                                                   *const VkSwapchainCreateInfoKHR,
                                               pAllocator:
                                                   *const VkAllocationCallbacks,
                                               pSwapchain:
                                                   *mut VkSwapchainKHR)
                              -> VkResult>;
pub type PFN_vkDestroySwapchainKHR =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               swapchain: VkSwapchainKHR,
                                               pAllocator:
                                                   *const VkAllocationCallbacks)>;
pub type PFN_vkGetSwapchainImagesKHR =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               swapchain: VkSwapchainKHR,
                                               pSwapchainImageCount:
                                                   *mut uint32_t,
                                               pSwapchainImages: *mut VkImage)
                              -> VkResult>;
pub type PFN_vkAcquireNextImageKHR =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               swapchain: VkSwapchainKHR,
                                               timeout: uint64_t,
                                               semaphore: VkSemaphore,
                                               fence: VkFence,
                                               pImageIndex: *mut uint32_t)
                              -> VkResult>;
pub type PFN_vkQueuePresentKHR =
    ::std::option::Option<unsafe extern "C" fn(queue: VkQueue,
                                               pPresentInfo:
                                                   *const VkPresentInfoKHR)
                              -> VkResult>;
pub enum Struct_VkDisplayKHR_T { }
pub type VkDisplayKHR = *mut Struct_VkDisplayKHR_T;
pub enum Struct_VkDisplayModeKHR_T { }
pub type VkDisplayModeKHR = *mut Struct_VkDisplayModeKHR_T;
#[derive(Clone, Eq, PartialEq, Debug, Copy)]
#[repr(u32)]
pub enum Enum_VkDisplayPlaneAlphaFlagBitsKHR {
    VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR = 1,
    VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR = 2,
    VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR = 4,
    VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR = 8,
}
pub type VkDisplayPlaneAlphaFlagBitsKHR = Enum_VkDisplayPlaneAlphaFlagBitsKHR;
pub type VkDisplayModeCreateFlagsKHR = VkFlags;
pub type VkDisplayPlaneAlphaFlagsKHR = VkFlags;
pub type VkDisplaySurfaceCreateFlagsKHR = VkFlags;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkDisplayPropertiesKHR {
    pub display: VkDisplayKHR,
    pub displayName: *const ::std::os::raw::c_char,
    pub physicalDimensions: VkExtent2D,
    pub physicalResolution: VkExtent2D,
    pub supportedTransforms: VkSurfaceTransformFlagsKHR,
    pub planeReorderPossible: VkBool32,
    pub persistentContent: VkBool32,
}
impl ::std::clone::Clone for Struct_VkDisplayPropertiesKHR {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkDisplayPropertiesKHR {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkDisplayPropertiesKHR = Struct_VkDisplayPropertiesKHR;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkDisplayModeParametersKHR {
    pub visibleRegion: VkExtent2D,
    pub refreshRate: uint32_t,
}
impl ::std::clone::Clone for Struct_VkDisplayModeParametersKHR {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkDisplayModeParametersKHR {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkDisplayModeParametersKHR = Struct_VkDisplayModeParametersKHR;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkDisplayModePropertiesKHR {
    pub displayMode: VkDisplayModeKHR,
    pub parameters: VkDisplayModeParametersKHR,
}
impl ::std::clone::Clone for Struct_VkDisplayModePropertiesKHR {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkDisplayModePropertiesKHR {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkDisplayModePropertiesKHR = Struct_VkDisplayModePropertiesKHR;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkDisplayModeCreateInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkDisplayModeCreateFlagsKHR,
    pub parameters: VkDisplayModeParametersKHR,
}
impl ::std::clone::Clone for Struct_VkDisplayModeCreateInfoKHR {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkDisplayModeCreateInfoKHR {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkDisplayModeCreateInfoKHR = Struct_VkDisplayModeCreateInfoKHR;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkDisplayPlaneCapabilitiesKHR {
    pub supportedAlpha: VkDisplayPlaneAlphaFlagsKHR,
    pub minSrcPosition: VkOffset2D,
    pub maxSrcPosition: VkOffset2D,
    pub minSrcExtent: VkExtent2D,
    pub maxSrcExtent: VkExtent2D,
    pub minDstPosition: VkOffset2D,
    pub maxDstPosition: VkOffset2D,
    pub minDstExtent: VkExtent2D,
    pub maxDstExtent: VkExtent2D,
}
impl ::std::clone::Clone for Struct_VkDisplayPlaneCapabilitiesKHR {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkDisplayPlaneCapabilitiesKHR {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkDisplayPlaneCapabilitiesKHR = Struct_VkDisplayPlaneCapabilitiesKHR;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkDisplayPlanePropertiesKHR {
    pub currentDisplay: VkDisplayKHR,
    pub currentStackIndex: uint32_t,
}
impl ::std::clone::Clone for Struct_VkDisplayPlanePropertiesKHR {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkDisplayPlanePropertiesKHR {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkDisplayPlanePropertiesKHR = Struct_VkDisplayPlanePropertiesKHR;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkDisplaySurfaceCreateInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkDisplaySurfaceCreateFlagsKHR,
    pub displayMode: VkDisplayModeKHR,
    pub planeIndex: uint32_t,
    pub planeStackIndex: uint32_t,
    pub transform: VkSurfaceTransformFlagBitsKHR,
    pub globalAlpha: ::std::os::raw::c_float,
    pub alphaMode: VkDisplayPlaneAlphaFlagBitsKHR,
    pub imageExtent: VkExtent2D,
}
impl ::std::clone::Clone for Struct_VkDisplaySurfaceCreateInfoKHR {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkDisplaySurfaceCreateInfoKHR {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkDisplaySurfaceCreateInfoKHR = Struct_VkDisplaySurfaceCreateInfoKHR;
pub type PFN_vkGetPhysicalDeviceDisplayPropertiesKHR =
    ::std::option::Option<unsafe extern "C" fn(physicalDevice:
                                                   VkPhysicalDevice,
                                               pPropertyCount: *mut uint32_t,
                                               pProperties:
                                                   *mut VkDisplayPropertiesKHR)
                              -> VkResult>;
pub type PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR =
    ::std::option::Option<unsafe extern "C" fn(physicalDevice:
                                                   VkPhysicalDevice,
                                               pPropertyCount: *mut uint32_t,
                                               pProperties:
                                                   *mut VkDisplayPlanePropertiesKHR)
                              -> VkResult>;
pub type PFN_vkGetDisplayPlaneSupportedDisplaysKHR =
    ::std::option::Option<unsafe extern "C" fn(physicalDevice:
                                                   VkPhysicalDevice,
                                               planeIndex: uint32_t,
                                               pDisplayCount: *mut uint32_t,
                                               pDisplays: *mut VkDisplayKHR)
                              -> VkResult>;
pub type PFN_vkGetDisplayModePropertiesKHR =
    ::std::option::Option<unsafe extern "C" fn(physicalDevice:
                                                   VkPhysicalDevice,
                                               display: VkDisplayKHR,
                                               pPropertyCount: *mut uint32_t,
                                               pProperties:
                                                   *mut VkDisplayModePropertiesKHR)
                              -> VkResult>;
pub type PFN_vkCreateDisplayModeKHR =
    ::std::option::Option<unsafe extern "C" fn(physicalDevice:
                                                   VkPhysicalDevice,
                                               display: VkDisplayKHR,
                                               pCreateInfo:
                                                   *const VkDisplayModeCreateInfoKHR,
                                               pAllocator:
                                                   *const VkAllocationCallbacks,
                                               pMode: *mut VkDisplayModeKHR)
                              -> VkResult>;
pub type PFN_vkGetDisplayPlaneCapabilitiesKHR =
    ::std::option::Option<unsafe extern "C" fn(physicalDevice:
                                                   VkPhysicalDevice,
                                               mode: VkDisplayModeKHR,
                                               planeIndex: uint32_t,
                                               pCapabilities:
                                                   *mut VkDisplayPlaneCapabilitiesKHR)
                              -> VkResult>;
pub type PFN_vkCreateDisplayPlaneSurfaceKHR =
    ::std::option::Option<unsafe extern "C" fn(instance: VkInstance,
                                               pCreateInfo:
                                                   *const VkDisplaySurfaceCreateInfoKHR,
                                               pAllocator:
                                                   *const VkAllocationCallbacks,
                                               pSurface: *mut VkSurfaceKHR)
                              -> VkResult>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkDisplayPresentInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub srcRect: VkRect2D,
    pub dstRect: VkRect2D,
    pub persistent: VkBool32,
}
impl ::std::clone::Clone for Struct_VkDisplayPresentInfoKHR {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkDisplayPresentInfoKHR {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkDisplayPresentInfoKHR = Struct_VkDisplayPresentInfoKHR;
pub type PFN_vkCreateSharedSwapchainsKHR =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               swapchainCount: uint32_t,
                                               pCreateInfos:
                                                   *const VkSwapchainCreateInfoKHR,
                                               pAllocator:
                                                   *const VkAllocationCallbacks,
                                               pSwapchains:
                                                   *mut VkSwapchainKHR)
                              -> VkResult>;
pub type VkXcbSurfaceCreateFlagsKHR = VkFlags;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VkXcbSurfaceCreateInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkXcbSurfaceCreateFlagsKHR,
    pub connection: *mut xcb_connection_t,
    pub window: xcb_window_t,
}
impl ::std::clone::Clone for Struct_VkXcbSurfaceCreateInfoKHR {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VkXcbSurfaceCreateInfoKHR {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VkXcbSurfaceCreateInfoKHR = Struct_VkXcbSurfaceCreateInfoKHR;
pub type PFN_vkCreateXcbSurfaceKHR =
    ::std::option::Option<unsafe extern "C" fn(instance: VkInstance,
                                               pCreateInfo:
                                                   *const VkXcbSurfaceCreateInfoKHR,
                                               pAllocator:
                                                   *const VkAllocationCallbacks,
                                               pSurface: *mut VkSurfaceKHR)
                              -> VkResult>;
pub type PFN_vkGetPhysicalDeviceXcbPresentationSupportKHR =
    ::std::option::Option<unsafe extern "C" fn(physicalDevice:
                                                   VkPhysicalDevice,
                                               queueFamilyIndex: uint32_t,
                                               connection:
                                                   *mut xcb_connection_t,
                                               visual_id: xcb_visualid_t)
                              -> VkBool32>;
#[link(name = "vulkan")]
extern "C" {
    pub fn vkCreateInstance(pCreateInfo: *const VkInstanceCreateInfo,
                            pAllocator: *const VkAllocationCallbacks,
                            pInstance: *mut VkInstance) -> VkResult;
    pub fn vkDestroyInstance(instance: VkInstance,
                             pAllocator: *const VkAllocationCallbacks);
    pub fn vkEnumeratePhysicalDevices(instance: VkInstance,
                                      pPhysicalDeviceCount: *mut uint32_t,
                                      pPhysicalDevices: *mut VkPhysicalDevice)
     -> VkResult;
    pub fn vkGetPhysicalDeviceFeatures(physicalDevice: VkPhysicalDevice,
                                       pFeatures:
                                           *mut VkPhysicalDeviceFeatures);
    pub fn vkGetPhysicalDeviceFormatProperties(physicalDevice:
                                                   VkPhysicalDevice,
                                               format: VkFormat,
                                               pFormatProperties:
                                                   *mut VkFormatProperties);
    pub fn vkGetPhysicalDeviceImageFormatProperties(physicalDevice:
                                                        VkPhysicalDevice,
                                                    format: VkFormat,
                                                    _type: VkImageType,
                                                    tiling: VkImageTiling,
                                                    usage: VkImageUsageFlags,
                                                    flags: VkImageCreateFlags,
                                                    pImageFormatProperties:
                                                        *mut VkImageFormatProperties)
     -> VkResult;
    pub fn vkGetPhysicalDeviceProperties(physicalDevice: VkPhysicalDevice,
                                         pProperties:
                                             *mut VkPhysicalDeviceProperties);
    pub fn vkGetPhysicalDeviceQueueFamilyProperties(physicalDevice:
                                                        VkPhysicalDevice,
                                                    pQueueFamilyPropertyCount:
                                                        *mut uint32_t,
                                                    pQueueFamilyProperties:
                                                        *mut VkQueueFamilyProperties);
    pub fn vkGetPhysicalDeviceMemoryProperties(physicalDevice:
                                                   VkPhysicalDevice,
                                               pMemoryProperties:
                                                   *mut VkPhysicalDeviceMemoryProperties);
    pub fn vkGetInstanceProcAddr(instance: VkInstance,
                                 pName: *const ::std::os::raw::c_char)
     -> PFN_vkVoidFunction;
    pub fn vkGetDeviceProcAddr(device: VkDevice,
                               pName: *const ::std::os::raw::c_char)
     -> PFN_vkVoidFunction;
    pub fn vkCreateDevice(physicalDevice: VkPhysicalDevice,
                          pCreateInfo: *const VkDeviceCreateInfo,
                          pAllocator: *const VkAllocationCallbacks,
                          pDevice: *mut VkDevice) -> VkResult;
    pub fn vkDestroyDevice(device: VkDevice,
                           pAllocator: *const VkAllocationCallbacks);
    pub fn vkEnumerateInstanceExtensionProperties(pLayerName:
                                                      *const ::std::os::raw::c_char,
                                                  pPropertyCount:
                                                      *mut uint32_t,
                                                  pProperties:
                                                      *mut VkExtensionProperties)
     -> VkResult;
    pub fn vkEnumerateDeviceExtensionProperties(physicalDevice:
                                                    VkPhysicalDevice,
                                                pLayerName:
                                                    *const ::std::os::raw::c_char,
                                                pPropertyCount: *mut uint32_t,
                                                pProperties:
                                                    *mut VkExtensionProperties)
     -> VkResult;
    pub fn vkEnumerateInstanceLayerProperties(pPropertyCount: *mut uint32_t,
                                              pProperties:
                                                  *mut VkLayerProperties)
     -> VkResult;
    pub fn vkEnumerateDeviceLayerProperties(physicalDevice: VkPhysicalDevice,
                                            pPropertyCount: *mut uint32_t,
                                            pProperties:
                                                *mut VkLayerProperties)
     -> VkResult;
    pub fn vkGetDeviceQueue(device: VkDevice, queueFamilyIndex: uint32_t,
                            queueIndex: uint32_t, pQueue: *mut VkQueue);
    pub fn vkQueueSubmit(queue: VkQueue, submitCount: uint32_t,
                         pSubmits: *const VkSubmitInfo, fence: VkFence)
     -> VkResult;
    pub fn vkQueueWaitIdle(queue: VkQueue) -> VkResult;
    pub fn vkDeviceWaitIdle(device: VkDevice) -> VkResult;
    pub fn vkAllocateMemory(device: VkDevice,
                            pAllocateInfo: *const VkMemoryAllocateInfo,
                            pAllocator: *const VkAllocationCallbacks,
                            pMemory: *mut VkDeviceMemory) -> VkResult;
    pub fn vkFreeMemory(device: VkDevice, memory: VkDeviceMemory,
                        pAllocator: *const VkAllocationCallbacks);
    pub fn vkMapMemory(device: VkDevice, memory: VkDeviceMemory,
                       offset: VkDeviceSize, size: VkDeviceSize,
                       flags: VkMemoryMapFlags,
                       ppData: *mut *mut ::std::os::raw::c_void) -> VkResult;
    pub fn vkUnmapMemory(device: VkDevice, memory: VkDeviceMemory);
    pub fn vkFlushMappedMemoryRanges(device: VkDevice,
                                     memoryRangeCount: uint32_t,
                                     pMemoryRanges:
                                         *const VkMappedMemoryRange)
     -> VkResult;
    pub fn vkInvalidateMappedMemoryRanges(device: VkDevice,
                                          memoryRangeCount: uint32_t,
                                          pMemoryRanges:
                                              *const VkMappedMemoryRange)
     -> VkResult;
    pub fn vkGetDeviceMemoryCommitment(device: VkDevice,
                                       memory: VkDeviceMemory,
                                       pCommittedMemoryInBytes:
                                           *mut VkDeviceSize);
    pub fn vkBindBufferMemory(device: VkDevice, buffer: VkBuffer,
                              memory: VkDeviceMemory,
                              memoryOffset: VkDeviceSize) -> VkResult;
    pub fn vkBindImageMemory(device: VkDevice, image: VkImage,
                             memory: VkDeviceMemory,
                             memoryOffset: VkDeviceSize) -> VkResult;
    pub fn vkGetBufferMemoryRequirements(device: VkDevice, buffer: VkBuffer,
                                         pMemoryRequirements:
                                             *mut VkMemoryRequirements);
    pub fn vkGetImageMemoryRequirements(device: VkDevice, image: VkImage,
                                        pMemoryRequirements:
                                            *mut VkMemoryRequirements);
    pub fn vkGetImageSparseMemoryRequirements(device: VkDevice,
                                              image: VkImage,
                                              pSparseMemoryRequirementCount:
                                                  *mut uint32_t,
                                              pSparseMemoryRequirements:
                                                  *mut VkSparseImageMemoryRequirements);
    pub fn vkGetPhysicalDeviceSparseImageFormatProperties(physicalDevice:
                                                              VkPhysicalDevice,
                                                          format: VkFormat,
                                                          _type: VkImageType,
                                                          samples:
                                                              VkSampleCountFlagBits,
                                                          usage:
                                                              VkImageUsageFlags,
                                                          tiling:
                                                              VkImageTiling,
                                                          pPropertyCount:
                                                              *mut uint32_t,
                                                          pProperties:
                                                              *mut VkSparseImageFormatProperties);
    pub fn vkQueueBindSparse(queue: VkQueue, bindInfoCount: uint32_t,
                             pBindInfo: *const VkBindSparseInfo,
                             fence: VkFence) -> VkResult;
    pub fn vkCreateFence(device: VkDevice,
                         pCreateInfo: *const VkFenceCreateInfo,
                         pAllocator: *const VkAllocationCallbacks,
                         pFence: *mut VkFence) -> VkResult;
    pub fn vkDestroyFence(device: VkDevice, fence: VkFence,
                          pAllocator: *const VkAllocationCallbacks);
    pub fn vkResetFences(device: VkDevice, fenceCount: uint32_t,
                         pFences: *const VkFence) -> VkResult;
    pub fn vkGetFenceStatus(device: VkDevice, fence: VkFence) -> VkResult;
    pub fn vkWaitForFences(device: VkDevice, fenceCount: uint32_t,
                           pFences: *const VkFence, waitAll: VkBool32,
                           timeout: uint64_t) -> VkResult;
    pub fn vkCreateSemaphore(device: VkDevice,
                             pCreateInfo: *const VkSemaphoreCreateInfo,
                             pAllocator: *const VkAllocationCallbacks,
                             pSemaphore: *mut VkSemaphore) -> VkResult;
    pub fn vkDestroySemaphore(device: VkDevice, semaphore: VkSemaphore,
                              pAllocator: *const VkAllocationCallbacks);
    pub fn vkCreateEvent(device: VkDevice,
                         pCreateInfo: *const VkEventCreateInfo,
                         pAllocator: *const VkAllocationCallbacks,
                         pEvent: *mut VkEvent) -> VkResult;
    pub fn vkDestroyEvent(device: VkDevice, event: VkEvent,
                          pAllocator: *const VkAllocationCallbacks);
    pub fn vkGetEventStatus(device: VkDevice, event: VkEvent) -> VkResult;
    pub fn vkSetEvent(device: VkDevice, event: VkEvent) -> VkResult;
    pub fn vkResetEvent(device: VkDevice, event: VkEvent) -> VkResult;
    pub fn vkCreateQueryPool(device: VkDevice,
                             pCreateInfo: *const VkQueryPoolCreateInfo,
                             pAllocator: *const VkAllocationCallbacks,
                             pQueryPool: *mut VkQueryPool) -> VkResult;
    pub fn vkDestroyQueryPool(device: VkDevice, queryPool: VkQueryPool,
                              pAllocator: *const VkAllocationCallbacks);
    pub fn vkGetQueryPoolResults(device: VkDevice, queryPool: VkQueryPool,
                                 firstQuery: uint32_t, queryCount: uint32_t,
                                 dataSize: size_t,
                                 pData: *mut ::std::os::raw::c_void,
                                 stride: VkDeviceSize,
                                 flags: VkQueryResultFlags) -> VkResult;
    pub fn vkCreateBuffer(device: VkDevice,
                          pCreateInfo: *const VkBufferCreateInfo,
                          pAllocator: *const VkAllocationCallbacks,
                          pBuffer: *mut VkBuffer) -> VkResult;
    pub fn vkDestroyBuffer(device: VkDevice, buffer: VkBuffer,
                           pAllocator: *const VkAllocationCallbacks);
    pub fn vkCreateBufferView(device: VkDevice,
                              pCreateInfo: *const VkBufferViewCreateInfo,
                              pAllocator: *const VkAllocationCallbacks,
                              pView: *mut VkBufferView) -> VkResult;
    pub fn vkDestroyBufferView(device: VkDevice, bufferView: VkBufferView,
                               pAllocator: *const VkAllocationCallbacks);
    pub fn vkCreateImage(device: VkDevice,
                         pCreateInfo: *const VkImageCreateInfo,
                         pAllocator: *const VkAllocationCallbacks,
                         pImage: *mut VkImage) -> VkResult;
    pub fn vkDestroyImage(device: VkDevice, image: VkImage,
                          pAllocator: *const VkAllocationCallbacks);
    pub fn vkGetImageSubresourceLayout(device: VkDevice, image: VkImage,
                                       pSubresource:
                                           *const VkImageSubresource,
                                       pLayout: *mut VkSubresourceLayout);
    pub fn vkCreateImageView(device: VkDevice,
                             pCreateInfo: *const VkImageViewCreateInfo,
                             pAllocator: *const VkAllocationCallbacks,
                             pView: *mut VkImageView) -> VkResult;
    pub fn vkDestroyImageView(device: VkDevice, imageView: VkImageView,
                              pAllocator: *const VkAllocationCallbacks);
    pub fn vkCreateShaderModule(device: VkDevice,
                                pCreateInfo: *const VkShaderModuleCreateInfo,
                                pAllocator: *const VkAllocationCallbacks,
                                pShaderModule: *mut VkShaderModule)
     -> VkResult;
    pub fn vkDestroyShaderModule(device: VkDevice,
                                 shaderModule: VkShaderModule,
                                 pAllocator: *const VkAllocationCallbacks);
    pub fn vkCreatePipelineCache(device: VkDevice,
                                 pCreateInfo:
                                     *const VkPipelineCacheCreateInfo,
                                 pAllocator: *const VkAllocationCallbacks,
                                 pPipelineCache: *mut VkPipelineCache)
     -> VkResult;
    pub fn vkDestroyPipelineCache(device: VkDevice,
                                  pipelineCache: VkPipelineCache,
                                  pAllocator: *const VkAllocationCallbacks);
    pub fn vkGetPipelineCacheData(device: VkDevice,
                                  pipelineCache: VkPipelineCache,
                                  pDataSize: *mut size_t,
                                  pData: *mut ::std::os::raw::c_void)
     -> VkResult;
    pub fn vkMergePipelineCaches(device: VkDevice, dstCache: VkPipelineCache,
                                 srcCacheCount: uint32_t,
                                 pSrcCaches: *const VkPipelineCache)
     -> VkResult;
    pub fn vkCreateGraphicsPipelines(device: VkDevice,
                                     pipelineCache: VkPipelineCache,
                                     createInfoCount: uint32_t,
                                     pCreateInfos:
                                         *const VkGraphicsPipelineCreateInfo,
                                     pAllocator: *const VkAllocationCallbacks,
                                     pPipelines: *mut VkPipeline) -> VkResult;
    pub fn vkCreateComputePipelines(device: VkDevice,
                                    pipelineCache: VkPipelineCache,
                                    createInfoCount: uint32_t,
                                    pCreateInfos:
                                        *const VkComputePipelineCreateInfo,
                                    pAllocator: *const VkAllocationCallbacks,
                                    pPipelines: *mut VkPipeline) -> VkResult;
    pub fn vkDestroyPipeline(device: VkDevice, pipeline: VkPipeline,
                             pAllocator: *const VkAllocationCallbacks);
    pub fn vkCreatePipelineLayout(device: VkDevice,
                                  pCreateInfo:
                                      *const VkPipelineLayoutCreateInfo,
                                  pAllocator: *const VkAllocationCallbacks,
                                  pPipelineLayout: *mut VkPipelineLayout)
     -> VkResult;
    pub fn vkDestroyPipelineLayout(device: VkDevice,
                                   pipelineLayout: VkPipelineLayout,
                                   pAllocator: *const VkAllocationCallbacks);
    pub fn vkCreateSampler(device: VkDevice,
                           pCreateInfo: *const VkSamplerCreateInfo,
                           pAllocator: *const VkAllocationCallbacks,
                           pSampler: *mut VkSampler) -> VkResult;
    pub fn vkDestroySampler(device: VkDevice, sampler: VkSampler,
                            pAllocator: *const VkAllocationCallbacks);
    pub fn vkCreateDescriptorSetLayout(device: VkDevice,
                                       pCreateInfo:
                                           *const VkDescriptorSetLayoutCreateInfo,
                                       pAllocator:
                                           *const VkAllocationCallbacks,
                                       pSetLayout: *mut VkDescriptorSetLayout)
     -> VkResult;
    pub fn vkDestroyDescriptorSetLayout(device: VkDevice,
                                        descriptorSetLayout:
                                            VkDescriptorSetLayout,
                                        pAllocator:
                                            *const VkAllocationCallbacks);
    pub fn vkCreateDescriptorPool(device: VkDevice,
                                  pCreateInfo:
                                      *const VkDescriptorPoolCreateInfo,
                                  pAllocator: *const VkAllocationCallbacks,
                                  pDescriptorPool: *mut VkDescriptorPool)
     -> VkResult;
    pub fn vkDestroyDescriptorPool(device: VkDevice,
                                   descriptorPool: VkDescriptorPool,
                                   pAllocator: *const VkAllocationCallbacks);
    pub fn vkResetDescriptorPool(device: VkDevice,
                                 descriptorPool: VkDescriptorPool,
                                 flags: VkDescriptorPoolResetFlags)
     -> VkResult;
    pub fn vkAllocateDescriptorSets(device: VkDevice,
                                    pAllocateInfo:
                                        *const VkDescriptorSetAllocateInfo,
                                    pDescriptorSets: *mut VkDescriptorSet)
     -> VkResult;
    pub fn vkFreeDescriptorSets(device: VkDevice,
                                descriptorPool: VkDescriptorPool,
                                descriptorSetCount: uint32_t,
                                pDescriptorSets: *const VkDescriptorSet)
     -> VkResult;
    pub fn vkUpdateDescriptorSets(device: VkDevice,
                                  descriptorWriteCount: uint32_t,
                                  pDescriptorWrites:
                                      *const VkWriteDescriptorSet,
                                  descriptorCopyCount: uint32_t,
                                  pDescriptorCopies:
                                      *const VkCopyDescriptorSet);
    pub fn vkCreateFramebuffer(device: VkDevice,
                               pCreateInfo: *const VkFramebufferCreateInfo,
                               pAllocator: *const VkAllocationCallbacks,
                               pFramebuffer: *mut VkFramebuffer) -> VkResult;
    pub fn vkDestroyFramebuffer(device: VkDevice, framebuffer: VkFramebuffer,
                                pAllocator: *const VkAllocationCallbacks);
    pub fn vkCreateRenderPass(device: VkDevice,
                              pCreateInfo: *const VkRenderPassCreateInfo,
                              pAllocator: *const VkAllocationCallbacks,
                              pRenderPass: *mut VkRenderPass) -> VkResult;
    pub fn vkDestroyRenderPass(device: VkDevice, renderPass: VkRenderPass,
                               pAllocator: *const VkAllocationCallbacks);
    pub fn vkGetRenderAreaGranularity(device: VkDevice,
                                      renderPass: VkRenderPass,
                                      pGranularity: *mut VkExtent2D);
    pub fn vkCreateCommandPool(device: VkDevice,
                               pCreateInfo: *const VkCommandPoolCreateInfo,
                               pAllocator: *const VkAllocationCallbacks,
                               pCommandPool: *mut VkCommandPool) -> VkResult;
    pub fn vkDestroyCommandPool(device: VkDevice, commandPool: VkCommandPool,
                                pAllocator: *const VkAllocationCallbacks);
    pub fn vkResetCommandPool(device: VkDevice, commandPool: VkCommandPool,
                              flags: VkCommandPoolResetFlags) -> VkResult;
    pub fn vkAllocateCommandBuffers(device: VkDevice,
                                    pAllocateInfo:
                                        *const VkCommandBufferAllocateInfo,
                                    pCommandBuffers: *mut VkCommandBuffer)
     -> VkResult;
    pub fn vkFreeCommandBuffers(device: VkDevice, commandPool: VkCommandPool,
                                commandBufferCount: uint32_t,
                                pCommandBuffers: *const VkCommandBuffer);
    pub fn vkBeginCommandBuffer(commandBuffer: VkCommandBuffer,
                                pBeginInfo: *const VkCommandBufferBeginInfo)
     -> VkResult;
    pub fn vkEndCommandBuffer(commandBuffer: VkCommandBuffer) -> VkResult;
    pub fn vkResetCommandBuffer(commandBuffer: VkCommandBuffer,
                                flags: VkCommandBufferResetFlags) -> VkResult;
    pub fn vkCmdBindPipeline(commandBuffer: VkCommandBuffer,
                             pipelineBindPoint: VkPipelineBindPoint,
                             pipeline: VkPipeline);
    pub fn vkCmdSetViewport(commandBuffer: VkCommandBuffer,
                            firstViewport: uint32_t, viewportCount: uint32_t,
                            pViewports: *const VkViewport);
    pub fn vkCmdSetScissor(commandBuffer: VkCommandBuffer,
                           firstScissor: uint32_t, scissorCount: uint32_t,
                           pScissors: *const VkRect2D);
    pub fn vkCmdSetLineWidth(commandBuffer: VkCommandBuffer,
                             lineWidth: ::std::os::raw::c_float);
    pub fn vkCmdSetDepthBias(commandBuffer: VkCommandBuffer,
                             depthBiasConstantFactor: ::std::os::raw::c_float,
                             depthBiasClamp: ::std::os::raw::c_float,
                             depthBiasSlopeFactor: ::std::os::raw::c_float);
    pub fn vkCmdSetBlendConstants(commandBuffer: VkCommandBuffer,
                                  blendConstants:
                                      *mut ::std::os::raw::c_float);
    pub fn vkCmdSetDepthBounds(commandBuffer: VkCommandBuffer,
                               minDepthBounds: ::std::os::raw::c_float,
                               maxDepthBounds: ::std::os::raw::c_float);
    pub fn vkCmdSetStencilCompareMask(commandBuffer: VkCommandBuffer,
                                      faceMask: VkStencilFaceFlags,
                                      compareMask: uint32_t);
    pub fn vkCmdSetStencilWriteMask(commandBuffer: VkCommandBuffer,
                                    faceMask: VkStencilFaceFlags,
                                    writeMask: uint32_t);
    pub fn vkCmdSetStencilReference(commandBuffer: VkCommandBuffer,
                                    faceMask: VkStencilFaceFlags,
                                    reference: uint32_t);
    pub fn vkCmdBindDescriptorSets(commandBuffer: VkCommandBuffer,
                                   pipelineBindPoint: VkPipelineBindPoint,
                                   layout: VkPipelineLayout,
                                   firstSet: uint32_t,
                                   descriptorSetCount: uint32_t,
                                   pDescriptorSets: *const VkDescriptorSet,
                                   dynamicOffsetCount: uint32_t,
                                   pDynamicOffsets: *const uint32_t);
    pub fn vkCmdBindIndexBuffer(commandBuffer: VkCommandBuffer,
                                buffer: VkBuffer, offset: VkDeviceSize,
                                indexType: VkIndexType);
    pub fn vkCmdBindVertexBuffers(commandBuffer: VkCommandBuffer,
                                  firstBinding: uint32_t,
                                  bindingCount: uint32_t,
                                  pBuffers: *const VkBuffer,
                                  pOffsets: *const VkDeviceSize);
    pub fn vkCmdDraw(commandBuffer: VkCommandBuffer, vertexCount: uint32_t,
                     instanceCount: uint32_t, firstVertex: uint32_t,
                     firstInstance: uint32_t);
    pub fn vkCmdDrawIndexed(commandBuffer: VkCommandBuffer,
                            indexCount: uint32_t, instanceCount: uint32_t,
                            firstIndex: uint32_t, vertexOffset: int32_t,
                            firstInstance: uint32_t);
    pub fn vkCmdDrawIndirect(commandBuffer: VkCommandBuffer, buffer: VkBuffer,
                             offset: VkDeviceSize, drawCount: uint32_t,
                             stride: uint32_t);
    pub fn vkCmdDrawIndexedIndirect(commandBuffer: VkCommandBuffer,
                                    buffer: VkBuffer, offset: VkDeviceSize,
                                    drawCount: uint32_t, stride: uint32_t);
    pub fn vkCmdDispatch(commandBuffer: VkCommandBuffer, x: uint32_t,
                         y: uint32_t, z: uint32_t);
    pub fn vkCmdDispatchIndirect(commandBuffer: VkCommandBuffer,
                                 buffer: VkBuffer, offset: VkDeviceSize);
    pub fn vkCmdCopyBuffer(commandBuffer: VkCommandBuffer,
                           srcBuffer: VkBuffer, dstBuffer: VkBuffer,
                           regionCount: uint32_t,
                           pRegions: *const VkBufferCopy);
    pub fn vkCmdCopyImage(commandBuffer: VkCommandBuffer, srcImage: VkImage,
                          srcImageLayout: VkImageLayout, dstImage: VkImage,
                          dstImageLayout: VkImageLayout,
                          regionCount: uint32_t,
                          pRegions: *const VkImageCopy);
    pub fn vkCmdBlitImage(commandBuffer: VkCommandBuffer, srcImage: VkImage,
                          srcImageLayout: VkImageLayout, dstImage: VkImage,
                          dstImageLayout: VkImageLayout,
                          regionCount: uint32_t, pRegions: *const VkImageBlit,
                          filter: VkFilter);
    pub fn vkCmdCopyBufferToImage(commandBuffer: VkCommandBuffer,
                                  srcBuffer: VkBuffer, dstImage: VkImage,
                                  dstImageLayout: VkImageLayout,
                                  regionCount: uint32_t,
                                  pRegions: *const VkBufferImageCopy);
    pub fn vkCmdCopyImageToBuffer(commandBuffer: VkCommandBuffer,
                                  srcImage: VkImage,
                                  srcImageLayout: VkImageLayout,
                                  dstBuffer: VkBuffer, regionCount: uint32_t,
                                  pRegions: *const VkBufferImageCopy);
    pub fn vkCmdUpdateBuffer(commandBuffer: VkCommandBuffer,
                             dstBuffer: VkBuffer, dstOffset: VkDeviceSize,
                             dataSize: VkDeviceSize, pData: *const uint32_t);
    pub fn vkCmdFillBuffer(commandBuffer: VkCommandBuffer,
                           dstBuffer: VkBuffer, dstOffset: VkDeviceSize,
                           size: VkDeviceSize, data: uint32_t);
    pub fn vkCmdClearColorImage(commandBuffer: VkCommandBuffer,
                                image: VkImage, imageLayout: VkImageLayout,
                                pColor: *const VkClearColorValue,
                                rangeCount: uint32_t,
                                pRanges: *const VkImageSubresourceRange);
    pub fn vkCmdClearDepthStencilImage(commandBuffer: VkCommandBuffer,
                                       image: VkImage,
                                       imageLayout: VkImageLayout,
                                       pDepthStencil:
                                           *const VkClearDepthStencilValue,
                                       rangeCount: uint32_t,
                                       pRanges:
                                           *const VkImageSubresourceRange);
    pub fn vkCmdClearAttachments(commandBuffer: VkCommandBuffer,
                                 attachmentCount: uint32_t,
                                 pAttachments: *const VkClearAttachment,
                                 rectCount: uint32_t,
                                 pRects: *const VkClearRect);
    pub fn vkCmdResolveImage(commandBuffer: VkCommandBuffer,
                             srcImage: VkImage, srcImageLayout: VkImageLayout,
                             dstImage: VkImage, dstImageLayout: VkImageLayout,
                             regionCount: uint32_t,
                             pRegions: *const VkImageResolve);
    pub fn vkCmdSetEvent(commandBuffer: VkCommandBuffer, event: VkEvent,
                         stageMask: VkPipelineStageFlags);
    pub fn vkCmdResetEvent(commandBuffer: VkCommandBuffer, event: VkEvent,
                           stageMask: VkPipelineStageFlags);
    pub fn vkCmdWaitEvents(commandBuffer: VkCommandBuffer,
                           eventCount: uint32_t, pEvents: *const VkEvent,
                           srcStageMask: VkPipelineStageFlags,
                           dstStageMask: VkPipelineStageFlags,
                           memoryBarrierCount: uint32_t,
                           pMemoryBarriers: *const VkMemoryBarrier,
                           bufferMemoryBarrierCount: uint32_t,
                           pBufferMemoryBarriers:
                               *const VkBufferMemoryBarrier,
                           imageMemoryBarrierCount: uint32_t,
                           pImageMemoryBarriers: *const VkImageMemoryBarrier);
    pub fn vkCmdPipelineBarrier(commandBuffer: VkCommandBuffer,
                                srcStageMask: VkPipelineStageFlags,
                                dstStageMask: VkPipelineStageFlags,
                                dependencyFlags: VkDependencyFlags,
                                memoryBarrierCount: uint32_t,
                                pMemoryBarriers: *const VkMemoryBarrier,
                                bufferMemoryBarrierCount: uint32_t,
                                pBufferMemoryBarriers:
                                    *const VkBufferMemoryBarrier,
                                imageMemoryBarrierCount: uint32_t,
                                pImageMemoryBarriers:
                                    *const VkImageMemoryBarrier);
    pub fn vkCmdBeginQuery(commandBuffer: VkCommandBuffer,
                           queryPool: VkQueryPool, query: uint32_t,
                           flags: VkQueryControlFlags);
    pub fn vkCmdEndQuery(commandBuffer: VkCommandBuffer,
                         queryPool: VkQueryPool, query: uint32_t);
    pub fn vkCmdResetQueryPool(commandBuffer: VkCommandBuffer,
                               queryPool: VkQueryPool, firstQuery: uint32_t,
                               queryCount: uint32_t);
    pub fn vkCmdWriteTimestamp(commandBuffer: VkCommandBuffer,
                               pipelineStage: VkPipelineStageFlagBits,
                               queryPool: VkQueryPool, query: uint32_t);
    pub fn vkCmdCopyQueryPoolResults(commandBuffer: VkCommandBuffer,
                                     queryPool: VkQueryPool,
                                     firstQuery: uint32_t,
                                     queryCount: uint32_t,
                                     dstBuffer: VkBuffer,
                                     dstOffset: VkDeviceSize,
                                     stride: VkDeviceSize,
                                     flags: VkQueryResultFlags);
    pub fn vkCmdPushConstants(commandBuffer: VkCommandBuffer,
                              layout: VkPipelineLayout,
                              stageFlags: VkShaderStageFlags,
                              offset: uint32_t, size: uint32_t,
                              pValues: *const ::std::os::raw::c_void);
    pub fn vkCmdBeginRenderPass(commandBuffer: VkCommandBuffer,
                                pRenderPassBegin:
                                    *const VkRenderPassBeginInfo,
                                contents: VkSubpassContents);
    pub fn vkCmdNextSubpass(commandBuffer: VkCommandBuffer,
                            contents: VkSubpassContents);
    pub fn vkCmdEndRenderPass(commandBuffer: VkCommandBuffer);
    pub fn vkCmdExecuteCommands(commandBuffer: VkCommandBuffer,
                                commandBufferCount: uint32_t,
                                pCommandBuffers: *const VkCommandBuffer);
    pub fn vkDestroySurfaceKHR(instance: VkInstance, surface: VkSurfaceKHR,
                               pAllocator: *const VkAllocationCallbacks);
    pub fn vkGetPhysicalDeviceSurfaceSupportKHR(physicalDevice:
                                                    VkPhysicalDevice,
                                                queueFamilyIndex: uint32_t,
                                                surface: VkSurfaceKHR,
                                                pSupported: *mut VkBool32)
     -> VkResult;
    pub fn vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice:
                                                         VkPhysicalDevice,
                                                     surface: VkSurfaceKHR,
                                                     pSurfaceCapabilities:
                                                         *mut VkSurfaceCapabilitiesKHR)
     -> VkResult;
    pub fn vkGetPhysicalDeviceSurfaceFormatsKHR(physicalDevice:
                                                    VkPhysicalDevice,
                                                surface: VkSurfaceKHR,
                                                pSurfaceFormatCount:
                                                    *mut uint32_t,
                                                pSurfaceFormats:
                                                    *mut VkSurfaceFormatKHR)
     -> VkResult;
    pub fn vkGetPhysicalDeviceSurfacePresentModesKHR(physicalDevice:
                                                         VkPhysicalDevice,
                                                     surface: VkSurfaceKHR,
                                                     pPresentModeCount:
                                                         *mut uint32_t,
                                                     pPresentModes:
                                                         *mut VkPresentModeKHR)
     -> VkResult;
    pub fn vkCreateSwapchainKHR(device: VkDevice,
                                pCreateInfo: *const VkSwapchainCreateInfoKHR,
                                pAllocator: *const VkAllocationCallbacks,
                                pSwapchain: *mut VkSwapchainKHR) -> VkResult;
    pub fn vkDestroySwapchainKHR(device: VkDevice, swapchain: VkSwapchainKHR,
                                 pAllocator: *const VkAllocationCallbacks);
    pub fn vkGetSwapchainImagesKHR(device: VkDevice,
                                   swapchain: VkSwapchainKHR,
                                   pSwapchainImageCount: *mut uint32_t,
                                   pSwapchainImages: *mut VkImage)
     -> VkResult;
    pub fn vkAcquireNextImageKHR(device: VkDevice, swapchain: VkSwapchainKHR,
                                 timeout: uint64_t, semaphore: VkSemaphore,
                                 fence: VkFence, pImageIndex: *mut uint32_t)
     -> VkResult;
    pub fn vkQueuePresentKHR(queue: VkQueue,
                             pPresentInfo: *const VkPresentInfoKHR)
     -> VkResult;
    pub fn vkGetPhysicalDeviceDisplayPropertiesKHR(physicalDevice:
                                                       VkPhysicalDevice,
                                                   pPropertyCount:
                                                       *mut uint32_t,
                                                   pProperties:
                                                       *mut VkDisplayPropertiesKHR)
     -> VkResult;
    pub fn vkGetPhysicalDeviceDisplayPlanePropertiesKHR(physicalDevice:
                                                            VkPhysicalDevice,
                                                        pPropertyCount:
                                                            *mut uint32_t,
                                                        pProperties:
                                                            *mut VkDisplayPlanePropertiesKHR)
     -> VkResult;
    pub fn vkGetDisplayPlaneSupportedDisplaysKHR(physicalDevice:
                                                     VkPhysicalDevice,
                                                 planeIndex: uint32_t,
                                                 pDisplayCount: *mut uint32_t,
                                                 pDisplays: *mut VkDisplayKHR)
     -> VkResult;
    pub fn vkGetDisplayModePropertiesKHR(physicalDevice: VkPhysicalDevice,
                                         display: VkDisplayKHR,
                                         pPropertyCount: *mut uint32_t,
                                         pProperties:
                                             *mut VkDisplayModePropertiesKHR)
     -> VkResult;
    pub fn vkCreateDisplayModeKHR(physicalDevice: VkPhysicalDevice,
                                  display: VkDisplayKHR,
                                  pCreateInfo:
                                      *const VkDisplayModeCreateInfoKHR,
                                  pAllocator: *const VkAllocationCallbacks,
                                  pMode: *mut VkDisplayModeKHR) -> VkResult;
    pub fn vkGetDisplayPlaneCapabilitiesKHR(physicalDevice: VkPhysicalDevice,
                                            mode: VkDisplayModeKHR,
                                            planeIndex: uint32_t,
                                            pCapabilities:
                                                *mut VkDisplayPlaneCapabilitiesKHR)
     -> VkResult;
    pub fn vkCreateDisplayPlaneSurfaceKHR(instance: VkInstance,
                                          pCreateInfo:
                                              *const VkDisplaySurfaceCreateInfoKHR,
                                          pAllocator:
                                              *const VkAllocationCallbacks,
                                          pSurface: *mut VkSurfaceKHR)
     -> VkResult;
    pub fn vkCreateSharedSwapchainsKHR(device: VkDevice,
                                       swapchainCount: uint32_t,
                                       pCreateInfos:
                                           *const VkSwapchainCreateInfoKHR,
                                       pAllocator:
                                           *const VkAllocationCallbacks,
                                       pSwapchains: *mut VkSwapchainKHR)
     -> VkResult;
    pub fn vkCreateXcbSurfaceKHR(instance: VkInstance,
                                 pCreateInfo:
                                     *const VkXcbSurfaceCreateInfoKHR,
                                 pAllocator: *const VkAllocationCallbacks,
                                 pSurface: *mut VkSurfaceKHR) -> VkResult;
    pub fn vkGetPhysicalDeviceXcbPresentationSupportKHR(physicalDevice:
                                                            VkPhysicalDevice,
                                                        queueFamilyIndex:
                                                            uint32_t,
                                                        connection:
                                                            *mut xcb_connection_t,
                                                        visual_id:
                                                            xcb_visualid_t)
     -> VkBool32;
}
